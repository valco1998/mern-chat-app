#!/usr/bin/env node
'use strict';

var constants = require('./constants.js');
var require$$0$2 = require('@babel/runtime/helpers/interopRequireWildcard');
var require$$0$1 = require('@babel/runtime/helpers/interopRequireDefault');
var require$$2$9 = require('node:url');
var require$$1$2 = require('yoctocolors-cjs');
var require$$4$1 = require('pony-cause');
var require$$5$5 = require('tiny-updater');
var require$$0 = require('node:fs');
var require$$1 = require('node:path');
var require$$1$1 = require('@npmcli/promise-spawn');
var require$$4 = require('yargs-parser');
var require$$5 = require('@socketsecurity/registry/lib/words');
var require$$2 = require('meow');
var require$$3 = require('@socketregistry/yocto-spinner');
var sdk = require('./sdk.js');
var require$$1$3 = require('@inquirer/prompts');
var require$$3$1 = require('is-interactive');
var require$$3$2 = require('terminal-link');
var require$$1$4 = require('node:fs/promises');
var require$$5$2 = require('npm-package-arg');
var require$$4$2 = require('semver');
var require$$8$1 = require('tinyglobby');
var require$$9$1 = require('yaml');
var require$$10 = require('@socketsecurity/registry');
var require$$7 = require('@socketsecurity/registry/lib/objects');
var require$$8 = require('@socketsecurity/registry/lib/packages');
var require$$13 = require('@socketsecurity/registry/lib/promises');
var require$$14 = require('@socketsecurity/registry/lib/regexps');
var require$$9 = require('@socketsecurity/registry/lib/strings');
var require$$2$1 = require('browserslist');
var require$$4$3 = require('which');
var require$$5$1 = require('@socketregistry/hyrious__bun.lockb');
var require$$3$3 = require('@socketsecurity/registry/lib/constants');
var require$$2$2 = require('@apideck/better-ajv-errors');
var require$$6 = require('@socketsecurity/config');
var pathResolve = require('./path-resolve.js');
var require$$2$3 = require('node:os');
var require$$3$4 = require('node:readline');
var require$$1$5 = require('node:process');
var require$$2$4 = require('node:readline/promises');
var require$$5$3 = require('open');
var require$$2$5 = require('chalk-table');
var require$$2$6 = require('blessed/lib/widgets/screen');
var require$$3$5 = require('blessed-contrib/lib/widget/charts/bar');
var require$$4$4 = require('blessed-contrib/lib/layout/grid');
var require$$5$4 = require('blessed-contrib/lib/widget/charts/line');
var require$$2$7 = require('node:util');
var require$$2$8 = require('blessed-contrib/lib/widget/table');

var cli$2 = {};

var cli$1 = {};

var commands = {};

var cdxgen = {};

Object.defineProperty(cdxgen, "__esModule", {
  value: true
});
cdxgen.cdxgen = void 0;
var _nodeFs$3 = require$$0;
var _nodePath$6 = require$$1;
var _promiseSpawn$6 = require$$1$1;
var _yoctocolorsCjs$j = require$$1$2;
var _yargsParser = require$$4;
var _words$1 = require$$5;
var _constants$6 = constants.constants;
const {
  execPath
} = process;
const {
  SBOM_SIGN_ALGORITHM,
  // Algorithm. Example: RS512
  SBOM_SIGN_PRIVATE_KEY,
  // Location to the RSA private key
  SBOM_SIGN_PUBLIC_KEY // Optional. Location to the RSA public key
} = process.env;
const toLower = arg => arg.toLowerCase();
const arrayToLower = arg => arg.map(toLower);
const nodejsPlatformTypes = new Set(['javascript', 'js', 'nodejs', 'npm', 'pnpm', 'ts', 'tsx', 'typescript']);
const yargsConfig = {
  configuration: {
    'camel-case-expansion': false,
    'strip-aliased': true,
    'parse-numbers': false,
    'populate--': true,
    'unknown-options-as-args': true
  },
  coerce: {
    author: arrayToLower,
    filter: arrayToLower,
    only: arrayToLower,
    profile: toLower,
    standard: arrayToLower,
    type: toLower
  },
  default: {
    //author: ['OWASP Foundation'],
    //'auto-compositions': true,
    //babel: true,
    //evidence: false,
    //'include-crypto': false,
    //'include-formulation': false,

    // Default 'install-deps' to `false` and 'lifecycle' to 'pre-build' to
    // sidestep arbitrary code execution during a cdxgen scan.
    // https://github.com/CycloneDX/cdxgen/issues/1328
    'install-deps': false,
    lifecycle: 'pre-build',
    //output: 'bom.json',
    //profile: 'generic',
    //'project-version': '',
    //recurse: true,
    //'server-host': '127.0.0.1',
    //'server-port': '9090',
    //'spec-version': '1.5',
    type: 'js'
    //validate: true,
  },
  alias: {
    help: ['h'],
    output: ['o'],
    print: ['p'],
    recurse: ['r'],
    'resolve-class': ['c'],
    type: ['t'],
    version: ['v']
  },
  array: [{
    key: 'author',
    type: 'string'
  }, {
    key: 'exclude',
    type: 'string'
  }, {
    key: 'filter',
    type: 'string'
  }, {
    key: 'only',
    type: 'string'
  }, {
    key: 'standard',
    type: 'string'
  }],
  boolean: ['auto-compositions', 'babel', 'deep', 'evidence', 'fail-on-error', 'generate-key-and-sign', 'help', 'include-formulation', 'include-crypto', 'install-deps', 'print', 'required-only', 'server', 'validate', 'version'],
  string: ['api-key', 'lifecycle', 'output', 'parent-project-id', 'profile', 'project-group', 'project-name', 'project-version', 'project-id', 'server-host', 'server-port', 'server-url', 'spec-version']
};
function argvToArray(argv) {
  if (argv['help']) return ['--help'];
  const result = [];
  for (const {
    0: key,
    1: value
  } of Object.entries(argv)) {
    if (key === '_' || key === '--') continue;
    if (key === 'babel' || key === 'install-deps' || key === 'validate') {
      // cdxgen documents no-babel, no-install-deps, and no-validate flags so
      // use them when relevant.
      result.push(`--${value ? key : `no-${key}`}`);
    } else if (value === true) {
      result.push(`--${key}`);
    } else if (typeof value === 'string') {
      result.push(`--${key}`, String(value));
    } else if (Array.isArray(value)) {
      result.push(`--${key}`, ...value.map(String));
    }
  }
  if (argv['--']) {
    result.push('--', ...argv['--']);
  }
  return result;
}
cdxgen.cdxgen = {
  description: 'Create an SBOM with CycloneDX generator (cdxgen)',
  async run(argv_) {
    const yargv = {
      ..._yargsParser(argv_, yargsConfig)
    };
    const unknown = yargv._;
    const {
      length: unknownLength
    } = unknown;
    if (unknownLength) {
      console.error(`Unknown ${(0, _words$1.pluralize)('argument', unknownLength)}: ${yargv._.join(', ')}`);
      process.exitCode = 1;
      return;
    }
    let cleanupPackageLock = false;
    if (yargv.type !== 'yarn' && nodejsPlatformTypes.has(yargv.type) && (0, _nodeFs$3.existsSync)('./yarn.lock')) {
      if ((0, _nodeFs$3.existsSync)('./package-lock.json')) {
        yargv.type = 'npm';
      } else {
        // Use synp to create a package-lock.json from the yarn.lock,
        // based on the node_modules folder, for a more accurate SBOM.
        try {
          await _promiseSpawn$6(execPath, [await _nodeFs$3.promises.realpath(_constants$6.synpBinPath), '--source-file', './yarn.lock'], {
            shell: true
          });
          yargv.type = 'npm';
          cleanupPackageLock = true;
        } catch {}
      }
    }
    if (yargv.output === undefined) {
      yargv.output = 'socket-cdx.json';
    }
    await _promiseSpawn$6(execPath, [await _nodeFs$3.promises.realpath(_constants$6.cdxgenBinPath), ...argvToArray(yargv)], {
      env: {
        NODE_ENV: '',
        SBOM_SIGN_ALGORITHM,
        SBOM_SIGN_PRIVATE_KEY,
        SBOM_SIGN_PUBLIC_KEY
      },
      shell: true,
      stdio: 'inherit'
    });
    if (cleanupPackageLock) {
      try {
        await _nodeFs$3.promises.unlink('./package-lock.json');
      } catch {}
    }
    const fullOutputPath = _nodePath$6.join(process.cwd(), yargv.output);
    if ((0, _nodeFs$3.existsSync)(fullOutputPath)) {
      console.log(_yoctocolorsCjs$j.cyanBright(`${yargv.output} created!`));
    }
  }
};

var info$1 = {};

var flags$1 = {};

Object.defineProperty(flags$1, "__esModule", {
  value: true
});
flags$1.validationFlags = flags$1.outputFlags = flags$1.commonFlags = flags$1.commandFlags = void 0;
flags$1.commonFlags = {
  help: {
    type: 'boolean',
    default: false,
    shortFlag: 'h',
    description: 'Print this help.'
  }
};
flags$1.commandFlags = {
  enable: {
    type: 'boolean',
    default: false,
    description: 'Enables the Socket npm/npx wrapper'
  },
  disable: {
    type: 'boolean',
    default: false,
    description: 'Disables the Socket npm/npx wrapper'
  }
};
flags$1.outputFlags = {
  json: {
    type: 'boolean',
    shortFlag: 'j',
    default: false,
    description: 'Output result as json'
  },
  markdown: {
    type: 'boolean',
    shortFlag: 'm',
    default: false,
    description: 'Output result as markdown'
  }
};
flags$1.validationFlags = {
  all: {
    type: 'boolean',
    default: false,
    description: 'Include all issues'
  },
  strict: {
    type: 'boolean',
    default: false,
    description: 'Exits with an error code if any matching issues are found'
  }
};

var apiHelpers = {};

Object.defineProperty(apiHelpers, "__esModule", {
  value: true
});
apiHelpers.handleAPIError = handleAPIError;
apiHelpers.handleApiCall = handleApiCall;
apiHelpers.handleUnsuccessfulApiResponse = handleUnsuccessfulApiResponse;
apiHelpers.queryAPI = queryAPI;
var _yoctocolorsCjs$i = require$$1$2;
var _ponyCause$4 = require$$4$1;
var _errors$l = sdk.errors;
var _constants$5 = constants.constants;
function handleUnsuccessfulApiResponse(_name, result, spinner) {
  // SocketSdkErrorType['error'] is not typed.
  const resultErrorMessage = result.error?.message;
  const message = typeof resultErrorMessage === 'string' ? resultErrorMessage : 'No error message returned';
  if (result.status === 401 || result.status === 403) {
    spinner.stop();
    throw new _errors$l.AuthError(message);
  }
  spinner.error(`${_yoctocolorsCjs$i.bgRed(_yoctocolorsCjs$i.white('API returned an error:'))} ${message}`);
  process.exit(1);
}
async function handleApiCall(value, description) {
  let result;
  try {
    result = await value;
  } catch (cause) {
    throw new _ponyCause$4.ErrorWithCause(`Failed ${description}`, {
      cause
    });
  }
  return result;
}
async function handleAPIError(code) {
  if (code === 400) {
    return 'One of the options passed might be incorrect.';
  } else if (code === 403) {
    return 'You might be trying to access an organization that is not linked to the API key you are logged in with.';
  }
}
async function queryAPI(path, apiKey) {
  return await fetch(`${_constants$5.API_V0_URL}/${path}`, {
    method: 'GET',
    headers: {
      Authorization: `Basic ${btoa(`${apiKey}:${apiKey}`)}`
    }
  });
}

var formatIssues = {};

var objects = {};

Object.defineProperty(objects, "__esModule", {
  value: true
});
objects.objectSome = objectSome;
objects.pick = pick;
function objectSome(obj) {
  for (const key in obj) {
    if (obj[key]) {
      return true;
    }
  }
  return false;
}
function pick(input, keys) {
  const result = {};
  for (const key of keys) {
    result[key] = input[key];
  }
  return result;
}

Object.defineProperty(formatIssues, "__esModule", {
  value: true
});
formatIssues.formatSeverityCount = formatSeverityCount;
formatIssues.getSeverityCount = getSeverityCount;
var _misc$2 = sdk.misc;
var _objects$4 = objects;
const SEVERITIES_BY_ORDER = ['critical', 'high', 'middle', 'low'];
function getDesiredSeverities(lowestToInclude) {
  const result = [];
  for (const severity of SEVERITIES_BY_ORDER) {
    result.push(severity);
    if (severity === lowestToInclude) {
      break;
    }
  }
  return result;
}
function formatSeverityCount(severityCount) {
  const summary = [];
  for (const severity of SEVERITIES_BY_ORDER) {
    if (severityCount[severity]) {
      summary.push(`${severityCount[severity]} ${severity}`);
    }
  }
  return (0, _misc$2.stringJoinWithSeparateFinalSeparator)(summary);
}
function getSeverityCount(issues, lowestToInclude) {
  const severityCount = (0, _objects$4.pick)({
    low: 0,
    middle: 0,
    high: 0,
    critical: 0
  }, getDesiredSeverities(lowestToInclude));
  for (const issue of issues) {
    const value = issue.value;
    if (!value) {
      continue;
    }
    if (severityCount[value.severity] !== undefined) {
      severityCount[value.severity] += 1;
    }
  }
  return severityCount;
}

var formatting = {};

Object.defineProperty(formatting, "__esModule", {
  value: true
});
formatting.printFlagList = printFlagList;
formatting.printHelpList = printHelpList;
function printFlagList(list, indent, {
  keyPrefix = '--',
  padName
} = {}) {
  return printHelpList({
    ...list
  }, indent, {
    keyPrefix,
    padName
  });
}
function printHelpList(list, indent, {
  keyPrefix = '',
  padName = 18
} = {}) {
  let result = '';
  const names = Object.keys(list).sort();
  for (const name of names) {
    const rawDescription = list[name];
    const description = (typeof rawDescription === 'object' ? rawDescription.description : rawDescription) || '';
    result += ''.padEnd(indent) + (keyPrefix + name).padEnd(padName) + description + '\n';
  }
  return result.trim();
}

var _interopRequireDefault$q = require$$0$1.default;
Object.defineProperty(info$1, "__esModule", {
  value: true
});
info$1.info = void 0;
var _yoctocolorsCjs$h = require$$1$2;
var _meow$p = _interopRequireDefault$q(require$$2);
var _yoctoSpinner$l = require$$3;
var _flags$k = flags$1;
var _apiHelpers$i = apiHelpers;
var _colorOrMarkdown$3 = sdk.colorOrMarkdown;
var _errors$k = sdk.errors;
var _formatIssues$1 = formatIssues;
var _formatting$m = formatting;
var _objects$3 = objects;
var _sdk$j = sdk.sdk;
const info = info$1.info = {
  description: 'Look up info regarding a package',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = parentName + ' info';
    const commandContext = setupCommand$m(name, info.description, argv, importMeta);
    if (commandContext) {
      const spinnerText = commandContext.pkgVersion === 'latest' ? `Looking up data for the latest version of ${commandContext.pkgName}` : `Looking up data for version ${commandContext.pkgVersion} of ${commandContext.pkgName}`;
      const spinner = _yoctoSpinner$l({
        text: spinnerText
      }).start();
      const packageData = await fetchPackageData(commandContext.pkgName, commandContext.pkgVersion, commandContext, spinner);
      if (packageData) {
        formatPackageDataOutput(packageData, {
          name,
          ...commandContext
        }, spinner);
      }
    }
  }
};

// Internal functions

function setupCommand$m(name, description, argv, importMeta) {
  const flags = {
    ..._flags$k.commonFlags,
    ..._flags$k.outputFlags,
    ..._flags$k.validationFlags
  };
  const cli = (0, _meow$p.default)(`
    Usage
      $ ${name} <name>

    Options
      ${(0, _formatting$m.printFlagList)(flags, 6)}

    Examples
      $ ${name} webtorrent
      $ ${name} webtorrent@1.9.1
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  if (cli.input.length > 1) {
    throw new _errors$k.InputError('Only one package lookup supported at once');
  }
  const {
    0: rawPkgName = ''
  } = cli.input;
  let showHelp = cli.flags['help'];
  if (!rawPkgName) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const versionSeparator = rawPkgName.lastIndexOf('@');
  const pkgName = versionSeparator < 1 ? rawPkgName : rawPkgName.slice(0, versionSeparator);
  const pkgVersion = versionSeparator < 1 ? 'latest' : rawPkgName.slice(versionSeparator + 1);
  return {
    includeAllIssues: cli.flags['all'],
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    pkgName,
    pkgVersion,
    strict: cli.flags['strict']
  };
}
async function fetchPackageData(pkgName, pkgVersion, {
  includeAllIssues
}, spinner) {
  const socketSdk = await (0, _sdk$j.setupSdk)((0, _sdk$j.getDefaultKey)() || _sdk$j.FREE_API_KEY);
  const result = await (0, _apiHelpers$i.handleApiCall)(socketSdk.getIssuesByNPMPackage(pkgName, pkgVersion), 'looking up package');
  const scoreResult = await (0, _apiHelpers$i.handleApiCall)(socketSdk.getScoreByNPMPackage(pkgName, pkgVersion), 'looking up package score');
  if (result.success === false) {
    return (0, _apiHelpers$i.handleUnsuccessfulApiResponse)('getIssuesByNPMPackage', result, spinner);
  }
  if (scoreResult.success === false) {
    return (0, _apiHelpers$i.handleUnsuccessfulApiResponse)('getScoreByNPMPackage', scoreResult, spinner);
  }
  const severityCount = (0, _formatIssues$1.getSeverityCount)(result.data, includeAllIssues ? undefined : 'high');
  return {
    data: result.data,
    severityCount,
    score: scoreResult.data
  };
}
function formatPackageDataOutput({
  data,
  score,
  severityCount
}, {
  name,
  outputJson,
  outputMarkdown,
  pkgName,
  pkgVersion,
  strict
}, spinner) {
  if (outputJson) {
    console.log(JSON.stringify(data, undefined, 2));
  } else {
    console.log('\nPackage report card:');
    const scoreResult = {
      'Supply Chain Risk': Math.floor(score.supplyChainRisk.score * 100),
      Maintenance: Math.floor(score.maintenance.score * 100),
      Quality: Math.floor(score.quality.score * 100),
      Vulnerabilities: Math.floor(score.vulnerability.score * 100),
      License: Math.floor(score.license.score * 100)
    };
    Object.entries(scoreResult).map(score => console.log(`- ${score[0]}: ${formatScore(score[1])}`));
    console.log('\n');
    if ((0, _objects$3.objectSome)(severityCount)) {
      spinner[strict ? 'error' : 'success'](`Package has these issues: ${(0, _formatIssues$1.formatSeverityCount)(severityCount)}`);
      formatPackageIssuesDetails(data, outputMarkdown);
    } else {
      spinner.success('Package has no issues');
    }
    const format = new _colorOrMarkdown$3.ColorOrMarkdown(!!outputMarkdown);
    const url = `https://socket.dev/npm/package/${pkgName}/overview/${pkgVersion}`;
    console.log('\n');
    if (pkgVersion === 'latest') {
      console.log(`Detailed info on socket.dev: ${format.hyperlink(`${pkgName}`, url, {
        fallbackToUrl: true
      })}`);
    } else {
      console.log(`Detailed info on socket.dev: ${format.hyperlink(`${pkgName} v${pkgVersion}`, url, {
        fallbackToUrl: true
      })}`);
    }
    if (!outputMarkdown) {
      console.log(_yoctocolorsCjs$h.dim(`\nOr rerun ${_yoctocolorsCjs$h.italic(name)} using the ${_yoctocolorsCjs$h.italic('--json')} flag to get full JSON output`));
    }
  }
  if (strict && (0, _objects$3.objectSome)(severityCount)) {
    process.exit(1);
  }
}
function formatPackageIssuesDetails(packageData, outputMarkdown) {
  const issueDetails = packageData.filter(d => d.value?.severity === 'high' || d.value?.severity === 'critical');
  const uniqueIssues = issueDetails.reduce((acc, issue) => {
    const {
      type
    } = issue;
    if (type) {
      if (acc[type] === undefined) {
        acc[type] = {
          label: issue.value?.label,
          count: 1
        };
      } else {
        acc[type].count += 1;
      }
    }
    return acc;
  }, {});
  const format = new _colorOrMarkdown$3.ColorOrMarkdown(!!outputMarkdown);
  for (const issue of Object.keys(uniqueIssues)) {
    const issueWithLink = format.hyperlink(`${uniqueIssues[issue]?.label}`, `https://socket.dev/npm/issue/${issue}`, {
      fallbackToUrl: true
    });
    if (uniqueIssues[issue]?.count === 1) {
      console.log(`- ${issueWithLink}`);
    } else {
      console.log(`- ${issueWithLink}: ${uniqueIssues[issue]?.count}`);
    }
  }
}
function formatScore(score) {
  if (score > 80) {
    return _yoctocolorsCjs$h.green(`${score}`);
  } else if (score < 80 && score > 60) {
    return _yoctocolorsCjs$h.yellow(`${score}`);
  }
  return _yoctocolorsCjs$h.red(`${score}`);
}

var login = {};

var _interopRequireDefault$p = require$$0$1.default;
Object.defineProperty(login, "__esModule", {
  value: true
});
login.login = void 0;
var _prompts$1 = require$$1$3;
var _isInteractive = _interopRequireDefault$p(require$$3$1);
var _meow$o = _interopRequireDefault$p(require$$2);
var _yoctoSpinner$k = require$$3;
var _terminalLink = _interopRequireDefault$p(require$$3$2);
var _errors$j = sdk.errors;
var _formatting$l = formatting;
var _sdk$i = sdk.sdk;
var _settings$1 = sdk.settings;
const description$7 = 'Socket API login';
const flags = {
  apiBaseUrl: {
    type: 'string',
    description: 'API server to connect to for login'
  },
  apiProxy: {
    type: 'string',
    description: 'Proxy to use when making connection to API server'
  }
};
function nonNullish(value) {
  return value !== null && value !== undefined;
}
login.login = {
  description: description$7,
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} login`;
    const cli = (0, _meow$o.default)(`
      Usage
        $ ${name}

      Logs into the Socket API by prompting for an API key

      Options
        ${(0, _formatting$l.printFlagList)({
      'api-base-url': flags['apiBaseUrl'].description,
      'api-proxy': flags['apiProxy'].description
    }, 8)}

      Examples
        $ ${name}
    `, {
      argv,
      description: description$7,
      importMeta,
      flags
    });
    let showHelp = cli.flags['help'];
    if (cli.input.length) {
      showHelp = true;
    }
    if (showHelp) {
      cli.showHelp();
      return;
    }
    if (!(0, _isInteractive.default)()) {
      throw new _errors$j.InputError('Cannot prompt for credentials in a non-interactive shell');
    }
    const apiKey = (await (0, _prompts$1.password)({
      message: `Enter your ${(0, _terminalLink.default)('Socket.dev API key', 'https://docs.socket.dev/docs/api-keys')} (leave blank for a public key)`
    })) || _sdk$i.FREE_API_KEY;
    let apiBaseUrl = cli.flags['apiBaseUrl'];
    apiBaseUrl ??= (0, _settings$1.getSetting)('apiBaseUrl') ?? undefined;
    let apiProxy = cli.flags['apiProxy'];
    apiProxy ??= (0, _settings$1.getSetting)('apiProxy') ?? undefined;
    const spinner = _yoctoSpinner$k({
      text: 'Verifying API key...'
    }).start();
    let orgs;
    try {
      const sdk = await (0, _sdk$i.setupSdk)(apiKey, apiBaseUrl, apiProxy);
      const result = await sdk.getOrganizations();
      if (!result.success) {
        throw new _errors$j.AuthError();
      }
      orgs = result.data;
      spinner.success('API key verified');
    } catch {
      spinner.error('Invalid API key');
      return;
    }
    const enforcedChoices = Object.values(orgs.organizations).filter(nonNullish).filter(org => org.plan === 'enterprise').map(org => ({
      name: org.name,
      value: org.id
    }));
    let enforcedOrgs = [];
    if (enforcedChoices.length > 1) {
      const id = await (0, _prompts$1.select)({
        message: "Which organization's policies should Socket enforce system-wide?",
        choices: enforcedChoices.concat({
          name: 'None',
          value: '',
          description: 'Pick "None" if this is a personal device'
        })
      });
      if (id) {
        enforcedOrgs = [id];
      }
    } else if (enforcedChoices.length) {
      const confirmOrg = await (0, _prompts$1.confirm)({
        message: `Should Socket enforce ${enforcedChoices[0]?.name}'s security policies system-wide?`,
        default: true
      });
      if (confirmOrg) {
        const existing = enforcedChoices[0];
        if (existing) {
          enforcedOrgs = [existing.value];
        }
      }
    }
    (0, _settings$1.updateSetting)('enforcedOrgs', enforcedOrgs);
    const oldKey = (0, _settings$1.getSetting)('apiKey');
    (0, _settings$1.updateSetting)('apiKey', apiKey);
    (0, _settings$1.updateSetting)('apiBaseUrl', apiBaseUrl);
    (0, _settings$1.updateSetting)('apiProxy', apiProxy);
    spinner.success(`API credentials ${oldKey ? 'updated' : 'set'}`);
  }
};

var logout = {};

var _interopRequireDefault$o = require$$0$1.default;
Object.defineProperty(logout, "__esModule", {
  value: true
});
logout.logout = void 0;
var _meow$n = _interopRequireDefault$o(require$$2);
var _yoctoSpinner$j = require$$3;
var _settings = sdk.settings;
const description$6 = 'Socket API logout';
logout.logout = {
  description: description$6,
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} logout`;
    const cli = (0, _meow$n.default)(`
      Usage
        $ ${name}

      Logs out of the Socket API and clears all Socket credentials from disk

      Examples
        $ ${name}
    `, {
      argv,
      description: description$6,
      importMeta
    });
    let showHelp = cli.flags['help'];
    if (cli.input.length) {
      showHelp = true;
    }
    if (showHelp) {
      cli.showHelp();
      return;
    }
    (0, _settings.updateSetting)('apiKey', null);
    (0, _settings.updateSetting)('apiBaseUrl', null);
    (0, _settings.updateSetting)('apiProxy', null);
    (0, _settings.updateSetting)('enforcedOrgs', null);
    _yoctoSpinner$j().success('Successfully logged out');
  }
};

var npm = {};

Object.defineProperty(npm, "__esModule", {
  value: true
});
npm.npm = void 0;
var _nodePath$5 = require$$1;
var _promiseSpawn$5 = require$$1$1;
var _constants$4 = constants.constants;
const description$5 = 'npm wrapper functionality';
npm.npm = {
  description: description$5,
  async run(argv, _importMeta, _ctx) {
    const wrapperPath = _nodePath$5.join(_constants$4.distPath, 'npm-cli.js');
    process.exitCode = 1;
    const spawnPromise = _promiseSpawn$5(process.execPath, ['--disable-warning', 'ExperimentalWarning', wrapperPath, ...argv], {
      stdio: 'inherit'
    });
    spawnPromise.process.on('exit', (code, signal) => {
      if (signal) {
        process.kill(process.pid, signal);
      } else if (code !== null) {
        process.exit(code);
      }
    });
    await spawnPromise;
  }
};

var npx = {};

Object.defineProperty(npx, "__esModule", {
  value: true
});
npx.npx = void 0;
var _nodePath$4 = require$$1;
var _promiseSpawn$4 = require$$1$1;
var _constants$3 = constants.constants;
const description$4 = 'npx wrapper functionality';
npx.npx = {
  description: description$4,
  async run(argv, _importMeta, _ctx) {
    const wrapperPath = _nodePath$4.join(_constants$3.distPath, 'npx-cli.js');
    process.exitCode = 1;
    const spawnPromise = _promiseSpawn$4(process.execPath, ['--disable-warning', 'ExperimentalWarning', wrapperPath, ...argv], {
      stdio: 'inherit'
    });
    spawnPromise.process.on('exit', (code, signal) => {
      if (signal) {
        process.kill(process.pid, signal);
      } else if (code !== null) {
        process.exit(code);
      }
    });
    await spawnPromise;
  }
};

var optimize$1 = {};

var fs = {};

Object.defineProperty(fs, "__esModule", {
  value: true
});
fs.existsSync = existsSync;
fs.findUp = findUp;
fs.readFileBinary = readFileBinary;
fs.readFileUtf8 = readFileUtf8;
var _nodeFs$2 = require$$0;
var _nodePath$3 = require$$1;
function existsSync(filepath) {
  try {
    return filepath ? (0, _nodeFs$2.existsSync)(filepath) : false;
  } catch {}
  return false;
}
async function findUp(name, {
  cwd = process.cwd()
}) {
  let dir = _nodePath$3.resolve(cwd);
  const {
    root
  } = _nodePath$3.parse(dir);
  const names = [name].flat();
  while (dir && dir !== root) {
    for (const name of names) {
      const filePath = _nodePath$3.join(dir, name);
      try {
        // eslint-disable-next-line no-await-in-loop
        const stats = await _nodeFs$2.promises.stat(filePath);
        if (stats.isFile()) {
          return filePath;
        }
      } catch {}
    }
    dir = _nodePath$3.dirname(dir);
  }
  return undefined;
}
async function readFileBinary(filepath, options) {
  return await _nodeFs$2.promises.readFile(filepath, {
    ...options,
    encoding: 'binary'
  });
}
async function readFileUtf8(filepath, options) {
  return await _nodeFs$2.promises.readFile(filepath, {
    ...options,
    encoding: 'utf8'
  });
}

var packageManagerDetector = {};

Object.defineProperty(packageManagerDetector, "__esModule", {
  value: true
});
packageManagerDetector.AGENTS = void 0;
packageManagerDetector.detect = detect;
var _nodePath$2 = require$$1;
var _promiseSpawn$3 = require$$1$1;
var _browserslist = require$$2$1;
var _semver$1 = require$$4$2;
var _which = require$$4$3;
var _hyrious__bun = require$$5$1;
var _constants$2 = require$$3$3;
var _objects$2 = require$$7;
var _packages$1 = require$$8;
var _strings$1 = require$$9;
var _fs$1 = fs;
const AGENTS = packageManagerDetector.AGENTS = ['bun', 'npm', 'pnpm', 'yarn/berry', 'yarn/classic', 'vlt'];
const {
  compare: alphanumericComparator
} = new Intl.Collator(undefined, {
  numeric: true,
  sensitivity: 'base'
});
async function getAgentExecPath(agent) {
  return (await _which(agent, {
    nothrow: true
  })) ?? agent;
}
async function getAgentVersion(agentExecPath, cwd) {
  let result;
  try {
    result = _semver$1.coerce(
    // All package managers support the "--version" flag.
    (await _promiseSpawn$3(agentExecPath, ['--version'], {
      cwd
    })).stdout) ?? undefined;
  } catch {}
  return result;
}
const LOCKS = {
  'bun.lockb': 'bun',
  // If both package-lock.json and npm-shrinkwrap.json are present in the root
  // of a project, npm-shrinkwrap.json will take precedence and package-lock.json
  // will be ignored.
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson
  'npm-shrinkwrap.json': 'npm',
  'package-lock.json': 'npm',
  'pnpm-lock.yaml': 'pnpm',
  'pnpm-lock.yml': 'pnpm',
  'yarn.lock': 'yarn/classic',
  'vlt-lock.json': 'vlt',
  // Look for a hidden lock file if .npmrc has package-lock=false:
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#hidden-lockfiles
  //
  // Unlike the other LOCKS keys this key contains a directory AND filename so
  // it has to be handled differently.
  'node_modules/.package-lock.json': 'npm'
};
const readLockFileByAgent = (() => {
  function wrapReader(reader) {
    return async (lockPath, agentExecPath) => {
      try {
        return await reader(lockPath, agentExecPath);
      } catch {}
      return undefined;
    };
  }
  const defaultReader = wrapReader(async lockPath => await (0, _fs$1.readFileUtf8)(lockPath));
  return {
    bun: wrapReader(async (lockPath, agentExecPath) => {
      let lockBuffer;
      try {
        lockBuffer = await (0, _fs$1.readFileBinary)(lockPath);
      } catch {
        return undefined;
      }
      try {
        return (0, _hyrious__bun.parse)(lockBuffer);
      } catch {}
      // To print a Yarn lockfile to your console without writing it to disk
      // use `bun bun.lockb`.
      // https://bun.sh/guides/install/yarnlock
      return (await _promiseSpawn$3(agentExecPath, [lockPath])).stdout.trim();
    }),
    npm: defaultReader,
    pnpm: defaultReader,
    vlt: defaultReader,
    'yarn/berry': defaultReader,
    'yarn/classic': defaultReader
  };
})();
async function detect({
  cwd = process.cwd(),
  onUnknown
} = {}) {
  let lockPath = await (0, _fs$1.findUp)(Object.keys(LOCKS), {
    cwd
  });
  const isHiddenLockFile = lockPath?.endsWith('.package-lock.json') ?? false;
  const pkgJsonPath = lockPath ? _nodePath$2.resolve(lockPath, `${isHiddenLockFile ? '../' : ''}../package.json`) : await (0, _fs$1.findUp)('package.json', {
    cwd
  });
  const pkgPath = (0, _fs$1.existsSync)(pkgJsonPath) ? _nodePath$2.dirname(pkgJsonPath) : undefined;
  const editablePkgJson = pkgPath ? await (0, _packages$1.readPackageJson)(pkgPath, {
    editable: true
  }) : undefined;
  const pkgJson = editablePkgJson?.content;
  // Read Corepack `packageManager` field in package.json:
  // https://nodejs.org/api/packages.html#packagemanager
  const pkgManager = (0, _strings$1.isNonEmptyString)(pkgJson?.packageManager) ? pkgJson.packageManager : undefined;
  let agent;
  let agentVersion;
  if (pkgManager) {
    const atSignIndex = pkgManager.lastIndexOf('@');
    if (atSignIndex !== -1) {
      const name = pkgManager.slice(0, atSignIndex);
      const version = pkgManager.slice(atSignIndex + 1);
      if (version && AGENTS.includes(name)) {
        agent = name;
        agentVersion = _semver$1.coerce(version) ?? undefined;
      }
    }
  }
  if (agent === undefined && !isHiddenLockFile && typeof pkgJsonPath === 'string' && typeof lockPath === 'string') {
    agent = LOCKS[_nodePath$2.basename(lockPath)];
  }
  if (agent === undefined) {
    agent = 'npm';
    onUnknown?.(pkgManager);
  }
  const agentExecPath = await getAgentExecPath(agent);
  const npmExecPath = agent === 'npm' ? agentExecPath : await getAgentExecPath('npm');
  if (agentVersion === undefined) {
    agentVersion = await getAgentVersion(agentExecPath, cwd);
  }
  if (agent === 'yarn/classic' && (agentVersion?.major ?? 0) > 1) {
    agent = 'yarn/berry';
  }
  const targets = {
    browser: false,
    node: true
  };
  let lockSrc;
  // Lazily access constants.maintainedNodeVersions.
  let minimumNodeVersion = _constants$2.maintainedNodeVersions.previous;
  if (pkgJson) {
    const browserField = pkgJson.browser;
    if ((0, _strings$1.isNonEmptyString)(browserField) || (0, _objects$2.isObjectObject)(browserField)) {
      targets.browser = true;
    }
    const nodeRange = pkgJson.engines?.['node'];
    if ((0, _strings$1.isNonEmptyString)(nodeRange)) {
      const coerced = _semver$1.coerce(nodeRange);
      if (coerced && _semver$1.lt(coerced, minimumNodeVersion)) {
        minimumNodeVersion = coerced.version;
      }
    }
    const browserslistQuery = pkgJson['browserslist'];
    if (Array.isArray(browserslistQuery)) {
      const browserslistTargets = _browserslist(browserslistQuery).map(s => s.toLowerCase()).sort(alphanumericComparator);
      const browserslistNodeTargets = browserslistTargets.filter(v => v.startsWith('node ')).map(v => v.slice(5 /*'node '.length*/));
      if (!targets.browser && browserslistTargets.length) {
        targets.browser = browserslistTargets.length !== browserslistNodeTargets.length;
      }
      if (browserslistNodeTargets.length) {
        const coerced = _semver$1.coerce(browserslistNodeTargets[0]);
        if (coerced && _semver$1.lt(coerced, minimumNodeVersion)) {
          minimumNodeVersion = coerced.version;
        }
      }
    }
    // Lazily access constants.maintainedNodeVersions.
    targets.node = _constants$2.maintainedNodeVersions.some(v => _semver$1.satisfies(v, `>=${minimumNodeVersion}`));
    lockSrc = typeof lockPath === 'string' ? await readLockFileByAgent[agent](lockPath, agentExecPath) : undefined;
  } else {
    lockPath = undefined;
  }
  return {
    agent,
    agentExecPath,
    agentVersion,
    lockPath,
    lockSrc,
    minimumNodeVersion,
    npmExecPath,
    pkgJson: editablePkgJson,
    pkgPath,
    supported: targets.browser || targets.node,
    targets
  };
}

var _interopRequireDefault$n = require$$0$1.default;
Object.defineProperty(optimize$1, "__esModule", {
  value: true
});
optimize$1.optimize = void 0;
var _promises$2 = require$$1$4;
var _nodePath$1 = require$$1;
var _promiseSpawn$2 = require$$1$1;
var _meow$m = _interopRequireDefault$n(require$$2);
var _npmPackageArg = require$$5$2;
var _yoctoSpinner$i = require$$3;
var _semver = require$$4$2;
var _tinyglobby = require$$8$1;
var _yaml = require$$9$1;
var _registry = require$$10;
var _objects$1 = require$$7;
var _packages = require$$8;
var _promises2 = require$$13;
var _regexps = require$$14;
var _strings = require$$9;
var _words = require$$5;
var _constants$1 = constants.constants;
var _flags$j = flags$1;
var _formatting$k = formatting;
var _fs = fs;
var _packageManagerDetector = packageManagerDetector;
const COMMAND_TITLE = 'Socket Optimize';
const OVERRIDES_FIELD_NAME = 'overrides';
const NPM_OVERRIDE_PR_URL = 'https://github.com/npm/cli/pull/7025';
const PNPM_FIELD_NAME = 'pnpm';
const PNPM_WORKSPACE = 'pnpm-workspace';
const RESOLUTIONS_FIELD_NAME = 'resolutions';
const manifestNpmOverrides = (0, _registry.getManifestData)('npm');
const getOverridesDataByAgent = {
  bun(pkgJson) {
    const overrides = pkgJson?.resolutions ?? {};
    return {
      type: 'yarn/berry',
      overrides
    };
  },
  // npm overrides documentation:
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-json#overrides
  npm(pkgJson) {
    const overrides = pkgJson?.overrides ?? {};
    return {
      type: 'npm',
      overrides
    };
  },
  // pnpm overrides documentation:
  // https://pnpm.io/package_json#pnpmoverrides
  pnpm(pkgJson) {
    const overrides = pkgJson?.pnpm?.overrides ?? {};
    return {
      type: 'pnpm',
      overrides
    };
  },
  vlt(pkgJson) {
    const overrides = pkgJson?.overrides ?? {};
    return {
      type: 'vlt',
      overrides
    };
  },
  // Yarn resolutions documentation:
  // https://yarnpkg.com/configuration/manifest#resolutions
  'yarn/berry'(pkgJson) {
    const overrides = pkgJson?.resolutions ?? {};
    return {
      type: 'yarn/berry',
      overrides
    };
  },
  // Yarn resolutions documentation:
  // https://classic.yarnpkg.com/en/docs/selective-version-resolutions
  'yarn/classic'(pkgJson) {
    const overrides = pkgJson?.resolutions ?? {};
    return {
      type: 'yarn/classic',
      overrides
    };
  }
};
const lockIncludesByAgent = (() => {
  function yarnLockIncludes(lockSrc, name) {
    const escapedName = (0, _regexps.escapeRegExp)(name);
    return new RegExp(
    // Detects the package name in the following cases:
    //   "name@
    //   , "name@
    //   name@
    //   , name@
    `(?<=(?:^\\s*|,\\s*)"?)${escapedName}(?=@)`, 'm').test(lockSrc);
  }
  return {
    bun: yarnLockIncludes,
    npm(lockSrc, name) {
      // Detects the package name in the following cases:
      //   "name":
      return lockSrc.includes(`"${name}":`);
    },
    pnpm(lockSrc, name) {
      const escapedName = (0, _regexps.escapeRegExp)(name);
      return new RegExp(
      // Detects the package name in the following cases:
      //   /name/
      //   'name'
      //   name:
      //   name@
      `(?<=^\\s*)(?:(['/])${escapedName}\\1|${escapedName}(?=[:@]))`, 'm').test(lockSrc);
    },
    vlt(lockSrc, name) {
      // Detects the package name in the following cases:
      //   "name"
      return lockSrc.includes(`"${name}"`);
    },
    'yarn/berry': yarnLockIncludes,
    'yarn/classic': yarnLockIncludes
  };
})();
const updateManifestByAgent = (() => {
  const depFields = ['dependencies', 'devDependencies', 'peerDependencies', 'peerDependenciesMeta', 'optionalDependencies', 'bundleDependencies'];
  function getEntryIndexes(entries, keys) {
    return keys.map(n => entries.findIndex(p => p[0] === n)).filter(n => n !== -1).sort((a, b) => a - b);
  }
  function getLowestEntryIndex(entries, keys) {
    return getEntryIndexes(entries, keys)?.[0] ?? -1;
  }
  function getHighestEntryIndex(entries, keys) {
    return getEntryIndexes(entries, keys).at(-1) ?? -1;
  }
  function updatePkgJson(editablePkgJson, field, value) {
    const pkgJson = editablePkgJson.content;
    const oldValue = pkgJson[field];
    if (oldValue) {
      // The field already exists so we simply update the field value.
      if (field === PNPM_FIELD_NAME) {
        if ((0, _objects$1.hasKeys)(value)) {
          editablePkgJson.update({
            [field]: {
              ...((0, _objects$1.isObject)(oldValue) ? oldValue : {}),
              overrides: value
            }
          });
        } else {
          // Properties with undefined values are omitted when saved as JSON.
          editablePkgJson.update((0, _objects$1.hasKeys)(pkgJson[field]) ? {
            [field]: {
              ...((0, _objects$1.isObject)(oldValue) ? oldValue : {}),
              overrides: undefined
            }
          } : {
            [field]: undefined
          });
        }
      } else if (field === OVERRIDES_FIELD_NAME || field === RESOLUTIONS_FIELD_NAME) {
        // Properties with undefined values are omitted when saved as JSON.
        editablePkgJson.update({
          [field]: (0, _objects$1.hasKeys)(value) ? value : undefined
        });
      } else {
        editablePkgJson.update({
          [field]: value
        });
      }
      return;
    }
    if ((field === OVERRIDES_FIELD_NAME || field === PNPM_FIELD_NAME || field === RESOLUTIONS_FIELD_NAME) && !(0, _objects$1.hasKeys)(value)) {
      return;
    }
    // Since the field doesn't exist we want to insert it into the package.json
    // in a place that makes sense, e.g. close to the "dependencies" field. If
    // we can't find a place to insert the field we'll add it to the bottom.
    const entries = Object.entries(pkgJson);
    let insertIndex = -1;
    let isPlacingHigher = false;
    if (field === OVERRIDES_FIELD_NAME) {
      insertIndex = getLowestEntryIndex(entries, ['resolutions']);
      if (insertIndex === -1) {
        isPlacingHigher = true;
        insertIndex = getHighestEntryIndex(entries, [...depFields, 'pnpm']);
      }
    } else if (field === RESOLUTIONS_FIELD_NAME) {
      isPlacingHigher = true;
      insertIndex = getHighestEntryIndex(entries, [...depFields, 'overrides', 'pnpm']);
    } else if (field === PNPM_FIELD_NAME) {
      insertIndex = getLowestEntryIndex(entries, ['overrides', 'resolutions']);
      if (insertIndex === -1) {
        isPlacingHigher = true;
        insertIndex = getHighestEntryIndex(entries, depFields);
      }
    }
    if (insertIndex === -1) {
      insertIndex = getLowestEntryIndex(entries, ['engines', 'files']);
    }
    if (insertIndex === -1) {
      isPlacingHigher = true;
      insertIndex = getHighestEntryIndex(entries, ['exports', 'imports', 'main']);
    }
    if (insertIndex === -1) {
      insertIndex = entries.length;
    } else if (isPlacingHigher) {
      insertIndex += 1;
    }
    entries.splice(insertIndex, 0, [field, value]);
    editablePkgJson.fromJSON(`${JSON.stringify(Object.fromEntries(entries), null, 2)}\n`);
  }
  function updateOverrides(editablePkgJson, overrides) {
    updatePkgJson(editablePkgJson, OVERRIDES_FIELD_NAME, overrides);
  }
  function updateResolutions(editablePkgJson, overrides) {
    updatePkgJson(editablePkgJson, RESOLUTIONS_FIELD_NAME, overrides);
  }
  return {
    bun: updateResolutions,
    npm: updateOverrides,
    pnpm(editablePkgJson, overrides) {
      updatePkgJson(editablePkgJson, PNPM_FIELD_NAME, overrides);
    },
    vlt: updateOverrides,
    'yarn/berry': updateResolutions,
    'yarn/classic': updateResolutions
  };
})();
const lsByAgent = (() => {
  function cleanupQueryStdout(stdout) {
    if (stdout === '') {
      return '';
    }
    let pkgs;
    try {
      pkgs = JSON.parse(stdout);
    } catch {}
    if (!Array.isArray(pkgs)) {
      return '';
    }
    const names = new Set();
    for (const {
      _id,
      name,
      pkgid
    } of pkgs) {
      // `npm query` results may not have a "name" property, in which case we
      // fallback to "_id" and then "pkgid".
      // `vlt ls --view json` results always have a "name" property.
      const fallback = _id ?? pkgid ?? '';
      const resolvedName = name ?? fallback.slice(0, fallback.indexOf('@', 1));
      // Add package names, except for those under the `@types` scope as those
      // are known to only be dev dependencies.
      if (resolvedName && !resolvedName.startsWith('@types/')) {
        names.add(resolvedName);
      }
    }
    return JSON.stringify([...names], null, 2);
  }
  function parseableToQueryStdout(stdout) {
    if (stdout === '') {
      return '';
    }
    // Convert the parseable stdout into a json array of unique names.
    // The matchAll regexp looks for a forward (posix) or backward (win32) slash
    // and matches one or more non-slashes until the newline.
    const names = new Set(stdout.matchAll(/(?<=[/\\])[^/\\]+(?=\n)/g));
    return JSON.stringify([...names], null, 2);
  }
  async function npmQuery(npmExecPath, cwd) {
    let stdout = '';
    try {
      stdout = (await _promiseSpawn$2(npmExecPath, ['query', ':not(.dev)'], {
        cwd
      })).stdout;
    } catch {}
    return cleanupQueryStdout(stdout);
  }
  return {
    async bun(agentExecPath, cwd) {
      try {
        // Bun does not support filtering by production packages yet.
        // https://github.com/oven-sh/bun/issues/8283
        return (await _promiseSpawn$2(agentExecPath, ['pm', 'ls', '--all'], {
          cwd
        })).stdout;
      } catch {}
      return '';
    },
    async npm(agentExecPath, cwd) {
      return await npmQuery(agentExecPath, cwd);
    },
    async pnpm(agentExecPath, cwd, options) {
      const {
        npmExecPath
      } = {
        __proto__: null,
        ...options
      };
      if (npmExecPath && npmExecPath !== 'npm') {
        const result = await npmQuery(npmExecPath, cwd);
        if (result) {
          return result;
        }
      }
      let stdout = '';
      try {
        stdout = (await _promiseSpawn$2(agentExecPath, ['ls', '--parseable', '--prod', '--depth', 'Infinity'], {
          cwd
        })).stdout;
      } catch {}
      return parseableToQueryStdout(stdout);
    },
    async vlt(agentExecPath, cwd) {
      let stdout = '';
      try {
        stdout = (await _promiseSpawn$2(agentExecPath, ['ls', '--view', 'human', ':not(.dev)'], {
          cwd
        })).stdout;
      } catch {}
      return cleanupQueryStdout(stdout);
    },
    async 'yarn/berry'(agentExecPath, cwd) {
      try {
        return (
          // Yarn Berry does not support filtering by production packages yet.
          // https://github.com/yarnpkg/berry/issues/5117
          (await _promiseSpawn$2(agentExecPath, ['info', '--recursive', '--name-only'], {
            cwd
          })).stdout.trim()
        );
      } catch {}
      return '';
    },
    async 'yarn/classic'(agentExecPath, cwd) {
      try {
        // However, Yarn Classic does support it.
        // https://github.com/yarnpkg/yarn/releases/tag/v1.0.0
        // > Fix: Excludes dev dependencies from the yarn list output when the
        //   environment is production
        return (await _promiseSpawn$2(agentExecPath, ['list', '--prod'], {
          cwd
        })).stdout.trim();
      } catch {}
      return '';
    }
  };
})();
const depsIncludesByAgent = (() => {
  function matchHumanStdout(stdout, name) {
    return stdout.includes(` ${name}@`);
  }
  function matchQueryStdout(stdout, name) {
    return stdout.includes(`"${name}"`);
  }
  return {
    bun: matchHumanStdout,
    npm: matchQueryStdout,
    pnpm: matchQueryStdout,
    vlt: matchQueryStdout,
    'yarn/berry': matchHumanStdout,
    'yarn/classic': matchHumanStdout
  };
})();
function createActionMessage(verb, overrideCount, workspaceCount) {
  return `${verb} ${overrideCount} Socket.dev optimized overrides${workspaceCount ? ` in ${workspaceCount} ${(0, _words.pluralize)('workspace', workspaceCount)}` : ''}`;
}
function getDependencyEntries(pkgJson) {
  const {
    dependencies,
    devDependencies,
    optionalDependencies,
    peerDependencies
  } = pkgJson;
  return [['dependencies', dependencies ? {
    __proto__: null,
    ...dependencies
  } : undefined], ['devDependencies', devDependencies ? {
    __proto__: null,
    ...devDependencies
  } : undefined], ['peerDependencies', peerDependencies ? {
    __proto__: null,
    ...peerDependencies
  } : undefined], ['optionalDependencies', optionalDependencies ? {
    __proto__: null,
    ...optionalDependencies
  } : undefined]].filter(({
    1: o
  }) => o);
}
async function getWorkspaceGlobs(agent, pkgPath, pkgJson) {
  let workspacePatterns;
  if (agent === 'pnpm') {
    for (const workspacePath of [_nodePath$1.join(pkgPath, `${PNPM_WORKSPACE}.yaml`), _nodePath$1.join(pkgPath, `${PNPM_WORKSPACE}.yml`)]) {
      if ((0, _fs.existsSync)(workspacePath)) {
        try {
          workspacePatterns = (0, _yaml.parse)(
          // eslint-disable-next-line no-await-in-loop
          await _promises$2.readFile(workspacePath, 'utf8'))?.packages;
        } catch {}
        if (workspacePatterns) {
          break;
        }
      }
    }
  } else {
    workspacePatterns = pkgJson['workspaces'];
  }
  return Array.isArray(workspacePatterns) ? workspacePatterns.filter(_strings.isNonEmptyString).map(workspacePatternToGlobPattern) : undefined;
}
function workspacePatternToGlobPattern(workspace) {
  const {
    length
  } = workspace;
  if (!length) {
    return '';
  }
  // If the workspace ends with "/"
  if (workspace.charCodeAt(length - 1) === 47 /*'/'*/) {
    return `${workspace}/*/package.json`;
  }
  // If the workspace ends with "/**"
  if (workspace.charCodeAt(length - 1) === 42 /*'*'*/ && workspace.charCodeAt(length - 2) === 42 /*'*'*/ && workspace.charCodeAt(length - 3) === 47 /*'/'*/) {
    return `${workspace}/*/**/package.json`;
  }
  // Things like "packages/a" or "packages/*"
  return `${workspace}/package.json`;
}
function createAddOverridesState(initials) {
  return {
    added: new Set(),
    addedInWorkspaces: new Set(),
    spinner: undefined,
    updated: new Set(),
    updatedInWorkspaces: new Set(),
    warnedPnpmWorkspaceRequiresNpm: false,
    ...initials
  };
}
async function addOverrides({
  agent,
  agentExecPath,
  lockSrc,
  manifestEntries,
  npmExecPath,
  pin,
  pkgJson: editablePkgJson,
  pkgPath,
  prod,
  rootPath
}, state = createAddOverridesState()) {
  if (editablePkgJson === undefined) {
    editablePkgJson = await (0, _packages.readPackageJson)(pkgPath, {
      editable: true
    });
  }
  const {
    spinner
  } = state;
  const {
    content: pkgJson
  } = editablePkgJson;
  const isRoot = pkgPath === rootPath;
  const isLockScanned = isRoot && !prod;
  const workspaceName = _nodePath$1.relative(rootPath, pkgPath);
  const workspaceGlobs = await getWorkspaceGlobs(agent, pkgPath, pkgJson);
  const isWorkspace = !!workspaceGlobs;
  if (isWorkspace && agent === 'pnpm' && npmExecPath === 'npm' && !state.warnedPnpmWorkspaceRequiresNpm) {
    state.warnedPnpmWorkspaceRequiresNpm = true;
    console.warn(`⚠️ ${COMMAND_TITLE}: pnpm workspace support requires \`npm ls\`, falling back to \`pnpm list\``);
  }
  const thingToScan = isLockScanned ? lockSrc : await lsByAgent[agent](agentExecPath, pkgPath, {
    npmExecPath
  });
  const thingScanner = isLockScanned ? lockIncludesByAgent[agent] : depsIncludesByAgent[agent];
  const depEntries = getDependencyEntries(pkgJson);
  const overridesDataObjects = [];
  if (pkgJson['private'] || isWorkspace) {
    overridesDataObjects.push(getOverridesDataByAgent[agent](pkgJson));
  } else {
    overridesDataObjects.push(getOverridesDataByAgent.npm(pkgJson), getOverridesDataByAgent['yarn/classic'](pkgJson));
  }
  if (spinner) {
    spinner.text = `Adding overrides${workspaceName ? ` to ${workspaceName}` : ''}...`;
  }
  const depAliasMap = new Map();
  // Chunk package names to process them in parallel 3 at a time.
  await (0, _promises2.pEach)(manifestEntries, 3, async ({
    1: data
  }) => {
    const {
      name: regPkgName,
      package: origPkgName,
      version
    } = data;
    const major = _semver.major(version);
    for (const {
      1: depObj
    } of depEntries) {
      let pkgSpec = depObj[origPkgName];
      if (pkgSpec) {
        let thisVersion = version;
        // Add package aliases for direct dependencies to avoid npm EOVERRIDE errors.
        // https://docs.npmjs.com/cli/v8/using-npm/package-spec#aliases
        const regSpecStartsLike = `npm:${regPkgName}@`;
        const existingVersion = pkgSpec.startsWith(regSpecStartsLike) ? _semver.coerce(_npmPackageArg(pkgSpec).rawSpec)?.version ?? '' : '';
        if (existingVersion) {
          thisVersion = existingVersion;
        } else {
          pkgSpec = `${regSpecStartsLike}^${version}`;
          depObj[origPkgName] = pkgSpec;
          state.added.add(regPkgName);
          if (workspaceName) {
            state.addedInWorkspaces.add(workspaceName);
          }
        }
        depAliasMap.set(origPkgName, {
          id: pkgSpec,
          version: thisVersion
        });
      }
    }
    if (isRoot) {
      // Chunk package names to process them in parallel 3 at a time.
      await (0, _promises2.pEach)(overridesDataObjects, 3, async ({
        overrides,
        type
      }) => {
        const overrideExists = (0, _objects$1.hasOwn)(overrides, origPkgName);
        if (overrideExists || thingScanner(thingToScan, origPkgName)) {
          const oldSpec = overrideExists ? overrides[origPkgName] : undefined;
          const depAlias = depAliasMap.get(origPkgName);
          const regSpecStartsLike = `npm:${regPkgName}@`;
          let newSpec = `${regSpecStartsLike}^${pin ? version : major}`;
          let thisVersion = version;
          if (depAlias && type === 'npm') {
            // With npm one may not set an override for a package that one directly
            // depends on unless both the dependency and the override itself share
            // the exact same spec. To make this limitation easier to deal with,
            // overrides may also be defined as a reference to a spec for a direct
            // dependency by prefixing the name of the package to match the version
            // of with a $.
            // https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides
            newSpec = `$${origPkgName}`;
          } else if (overrideExists) {
            const thisSpec = oldSpec.startsWith('$') ? depAlias?.id ?? newSpec : oldSpec ?? newSpec;
            if (thisSpec.startsWith(regSpecStartsLike)) {
              if (pin) {
                thisVersion = _semver.major(_semver.coerce(_npmPackageArg(thisSpec).rawSpec)?.version ?? version) === major ? version : (await (0, _packages.fetchPackageManifest)(thisSpec))?.version ?? version;
              }
              newSpec = `${regSpecStartsLike}^${pin ? thisVersion : _semver.major(thisVersion)}`;
            } else {
              newSpec = oldSpec;
            }
          }
          if (newSpec !== oldSpec) {
            overrides[origPkgName] = newSpec;
            const addedOrUpdated = overrideExists ? 'updated' : 'added';
            state[addedOrUpdated].add(regPkgName);
            if (workspaceName) {
              const addedOrUpdatedIn = overrideExists ? 'updatedInWorkspaces' : 'addedInWorkspaces';
              state[addedOrUpdatedIn].add(workspaceName);
            }
          }
        }
      });
    }
  });
  if (workspaceGlobs) {
    const workspacePkgJsonPaths = await (0, _tinyglobby.glob)(workspaceGlobs, {
      absolute: true,
      cwd: pkgPath,
      ignore: ['**/node_modules/**', '**/bower_components/**']
    });
    // Chunk package names to process them in parallel 3 at a time.
    await (0, _promises2.pEach)(workspacePkgJsonPaths, 3, async workspacePkgJsonPath => {
      const otherState = await addOverrides({
        agent,
        agentExecPath,
        lockSrc,
        manifestEntries,
        npmExecPath,
        pin,
        pkgPath: _nodePath$1.dirname(workspacePkgJsonPath),
        prod,
        rootPath
      }, createAddOverridesState({
        spinner
      }));
      for (const key of ['added', 'addedInWorkspaces', 'updated', 'updatedInWorkspaces']) {
        for (const value of otherState[key]) {
          state[key].add(value);
        }
      }
    });
  }
  if (state.added.size > 0 || state.updated.size > 0) {
    editablePkgJson.update(Object.fromEntries(depEntries));
    for (const {
      overrides,
      type
    } of overridesDataObjects) {
      updateManifestByAgent[type](editablePkgJson, (0, _objects$1.toSortedObject)(overrides));
    }
    await editablePkgJson.save();
  }
  return state;
}
const optimize = optimize$1.optimize = {
  description: 'Optimize dependencies with @socketregistry overrides',
  async run(argv, importMeta, {
    parentName
  }) {
    const commandContext = setupCommand$l(`${parentName} optimize`, optimize.description, argv, importMeta);
    if (!commandContext) {
      return;
    }
    const {
      pin,
      prod
    } = commandContext;
    const cwd = process.cwd();
    const {
      agent,
      agentExecPath,
      agentVersion,
      lockPath,
      lockSrc,
      minimumNodeVersion,
      npmExecPath,
      pkgJson,
      pkgPath,
      supported
    } = await (0, _packageManagerDetector.detect)({
      cwd,
      onUnknown(pkgManager) {
        console.warn(`⚠️ ${COMMAND_TITLE}: Unknown package manager${pkgManager ? ` ${pkgManager}` : ''}, defaulting to npm`);
      }
    });
    if (!supported) {
      console.error(`✖️ ${COMMAND_TITLE}: No supported Node or browser range detected`);
      return;
    }
    if (agent === 'vlt') {
      console.error(`✖️ ${COMMAND_TITLE}: ${agent} does not support overrides. Soon, though ⚡`);
      return;
    }
    const lockName = lockPath ? _nodePath$1.basename(lockPath) : 'lock file';
    if (lockSrc === undefined) {
      console.error(`✖️ ${COMMAND_TITLE}: No ${lockName} found`);
      return;
    }
    if (lockSrc.trim() === '') {
      console.error(`✖️ ${COMMAND_TITLE}: ${lockName} is empty`);
      return;
    }
    if (pkgPath === undefined) {
      console.error(`✖️ ${COMMAND_TITLE}: No package.json found`);
      return;
    }
    if (prod && (agent === 'bun' || agent === 'yarn/berry')) {
      console.error(`✖️ ${COMMAND_TITLE}: --prod not supported for ${agent}${agentVersion ? `@${agentVersion.toString()}` : ''}`);
      return;
    }
    if (lockPath && _nodePath$1.relative(cwd, lockPath).startsWith('.')) {
      console.warn(`⚠️ ${COMMAND_TITLE}: Package ${lockName} found at ${lockPath}`);
    }
    const spinner = _yoctoSpinner$i({
      text: 'Socket optimizing...'
    });
    const state = createAddOverridesState({
      spinner
    });
    spinner.start();
    const nodeRange = `>=${minimumNodeVersion}`;
    const manifestEntries = manifestNpmOverrides.filter(({
      1: data
    }) => _semver.satisfies(_semver.coerce(data.engines.node), nodeRange));
    await addOverrides({
      agent,
      agentExecPath,
      lockSrc,
      manifestEntries,
      npmExecPath,
      pin,
      pkgJson,
      pkgPath,
      prod,
      rootPath: pkgPath
    }, state);
    spinner.stop();
    const addedCount = state.added.size;
    const updatedCount = state.updated.size;
    const pkgJsonChanged = addedCount > 0 || updatedCount > 0;
    if (pkgJsonChanged) {
      if (updatedCount > 0) {
        console.log(`${createActionMessage('Updated', updatedCount, state.updatedInWorkspaces.size)}${addedCount ? '.' : '🚀'}`);
      }
      if (addedCount > 0) {
        console.log(`${createActionMessage('Added', addedCount, state.addedInWorkspaces.size)} 🚀`);
      }
    } else {
      console.log('Congratulations! Already Socket.dev optimized 🎉');
    }
    const isNpm = agent === 'npm';
    if (isNpm || pkgJsonChanged) {
      // Always update package-lock.json until the npm overrides PR lands:
      // https://github.com/npm/cli/pull/7025
      spinner.start(`Updating ${lockName}...`);
      try {
        if (isNpm) {
          const wrapperPath = _nodePath$1.join(_constants$1.distPath, 'npm-cli.js');
          await _promiseSpawn$2(process.execPath, [wrapperPath, 'install', '--silent'], {
            stdio: 'ignore',
            env: {
              ...process.env,
              [_constants$1.UPDATE_SOCKET_OVERRIDES_IN_PACKAGE_LOCK_FILE]: '1'
            }
          });
        } else {
          // All package managers support the "install" command.
          await _promiseSpawn$2(agentExecPath, ['install'], {
            stdio: 'ignore'
          });
        }
        spinner.stop();
        if (isNpm) {
          console.log(`💡 Re-run ${COMMAND_TITLE} whenever ${lockName} changes.\n   This can be skipped once npm ships ${NPM_OVERRIDE_PR_URL}.`);
        }
      } catch {
        spinner.error(`${COMMAND_TITLE}: ${agent} install failed to update ${lockName}`);
      }
    }
  }
};

// Internal functions

function setupCommand$l(name, description, argv, importMeta) {
  const flags = {
    ..._flags$j.commonFlags,
    pin: {
      type: 'boolean',
      default: false,
      description: 'Pin overrides to their latest version'
    },
    prod: {
      type: 'boolean',
      default: false,
      description: 'Only add overrides for production dependencies'
    }
  };
  const cli = (0, _meow$m.default)(`
    Usage
      $ ${name}

    Options
      ${(0, _formatting$k.printFlagList)(flags, 6)}

    Examples
      $ ${name}
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    help,
    pin,
    prod
  } = cli.flags;
  if (help) {
    cli.showHelp();
    return;
  }
  return {
    pin,
    prod
  };
}

var organization = {};

var _interopRequireDefault$m = require$$0$1.default;
Object.defineProperty(organization, "__esModule", {
  value: true
});
organization.organizations = void 0;
var _yoctocolorsCjs$g = require$$1$2;
var _meow$l = _interopRequireDefault$m(require$$2);
var _yoctoSpinner$h = require$$3;
var _apiHelpers$h = apiHelpers;
var _errors$i = sdk.errors;
var _sdk$h = sdk.sdk;
const organizations = organization.organizations = {
  description: 'List organizations associated with the API key used',
  async run(argv, importMeta, {
    parentName
  }) {
    setupCommand$k(`${parentName} organizations`, organizations.description, argv, importMeta);
    await fetchOrganizations();
  }
};

// Internal functions

function setupCommand$k(name, description, argv, importMeta) {
  (0, _meow$l.default)(`
    Usage
      $ ${name}
  `, {
    argv,
    description,
    importMeta
  });
}
async function fetchOrganizations() {
  const apiKey = (0, _sdk$h.getDefaultKey)();
  if (!apiKey) {
    throw new _errors$i.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  const spinner = _yoctoSpinner$h({
    text: 'Fetching organizations...'
  }).start();
  const socketSdk = await (0, _sdk$h.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$h.handleApiCall)(socketSdk.getOrganizations(), 'looking up organizations');
  if (result.success === false) {
    (0, _apiHelpers$h.handleUnsuccessfulApiResponse)('getOrganizations', result, spinner);
    return;
  }
  spinner.stop(`List of organizations associated with your API key: ${_yoctocolorsCjs$g.italic(apiKey)}`);
  const organizations = Object.values(result.data.organizations);
  for (const o of organizations) {
    console.log(`
Name: ${o?.name}
ID: ${o?.id}
Plan: ${o?.plan}
    `);
  }
}

var rawNpm$1 = {};

var _interopRequireDefault$l = require$$0$1.default;
Object.defineProperty(rawNpm$1, "__esModule", {
  value: true
});
rawNpm$1.rawNpm = void 0;
var _promiseSpawn$1 = require$$1$1;
var _meow$k = _interopRequireDefault$l(require$$2);
var _flags$i = flags$1;
var _formatting$j = formatting;
const rawNpm = rawNpm$1.rawNpm = {
  description: 'Temporarily disable the Socket npm wrapper',
  async run(argv, importMeta, {
    parentName
  }) {
    await setupCommand$j(`${parentName} raw-npm`, rawNpm.description, argv, importMeta);
  }
};
async function setupCommand$j(name, description, argv, importMeta) {
  const flags = {
    ..._flags$i.commonFlags,
    ..._flags$i.validationFlags
  };
  const cli = (0, _meow$k.default)(`
    Usage
      $ ${name} <npm command>

    Options
      ${(0, _formatting$j.printFlagList)(flags, 6)}

    Examples
      $ ${name} install
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!argv[0]) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const spawnPromise = _promiseSpawn$1('npm', argv, {
    stdio: 'inherit'
  });
  spawnPromise.process.on('exit', (code, signal) => {
    if (signal) {
      process.kill(process.pid, signal);
    } else if (code !== null) {
      process.exit(code);
    }
  });
  await spawnPromise;
}

var rawNpx$1 = {};

var _interopRequireDefault$k = require$$0$1.default;
Object.defineProperty(rawNpx$1, "__esModule", {
  value: true
});
rawNpx$1.rawNpx = void 0;
var _promiseSpawn = require$$1$1;
var _meow$j = _interopRequireDefault$k(require$$2);
var _flags$h = flags$1;
var _formatting$i = formatting;
const rawNpx = rawNpx$1.rawNpx = {
  description: 'Temporarily disable the Socket npm/npx wrapper',
  async run(argv, importMeta, {
    parentName
  }) {
    await setupCommand$i(`${parentName} raw-npx`, rawNpx.description, argv, importMeta);
  }
};
async function setupCommand$i(name, description, argv, importMeta) {
  const flags = {
    ..._flags$h.commonFlags,
    ..._flags$h.validationFlags
  };
  const cli = (0, _meow$j.default)(`
    Usage
      $ ${name} <npx command>

    Options
      ${(0, _formatting$i.printFlagList)(flags, 6)}

    Examples
      $ ${name} install
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!argv[0]) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const spawnPromise = _promiseSpawn('npx', [argv.join(' ')], {
    stdio: 'inherit'
  });
  spawnPromise.process.on('exit', (code, signal) => {
    if (signal) {
      process.kill(process.pid, signal);
    } else if (code !== null) {
      process.exit(code);
    }
  });
  await spawnPromise;
}

var report = {};

var create$5 = {};

var view$3 = {};

var _interopRequireDefault$j = require$$0$1.default;
Object.defineProperty(view$3, "__esModule", {
  value: true
});
view$3.fetchReportData = fetchReportData;
view$3.formatReportDataOutput = formatReportDataOutput;
view$3.view = void 0;
var _yoctocolorsCjs$f = require$$1$2;
var _meow$i = _interopRequireDefault$j(require$$2);
var _yoctoSpinner$g = require$$3;
var _ponyCause$3 = require$$4$1;
var _flags$g = flags$1;
var _apiHelpers$g = apiHelpers;
var _colorOrMarkdown$2 = sdk.colorOrMarkdown;
var _errors$h = sdk.errors;
var _formatIssues = formatIssues;
var _formatting$h = formatting;
var _sdk$g = sdk.sdk;
const view$2 = view$3.view = {
  description: 'View a project report',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} view`;
    const commandContext = setupCommand$h(name, view$2.description, argv, importMeta);
    const result = commandContext ? await fetchReportData(commandContext.reportId, commandContext) : undefined;
    if (result) {
      formatReportDataOutput(result, {
        name,
        ...(commandContext ?? {})
      });
    }
  }
};

// Internal functions

function setupCommand$h(name, description, argv, importMeta) {
  const flags = {
    ..._flags$g.commonFlags,
    ..._flags$g.outputFlags,
    ..._flags$g.validationFlags
  };
  const cli = (0, _meow$i.default)(`
    Usage
      $ ${name} <report-identifier>

    Options
      ${(0, _formatting$h.printFlagList)(flags, 6)}

    Examples
      $ ${name} QXU8PmK7LfH608RAwfIKdbcHgwEd_ZeWJ9QEGv05FJUQ
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  // Extract the input.
  const [reportId, ...extraInput] = cli.input;
  let showHelp = cli.flags['help'];
  if (reportId) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  // Validate the input.
  if (extraInput.length) {
    throw new _errors$h.InputError(`Can only handle a single report ID at a time, but got ${cli.input.length} report ID:s: ${cli.input.join(', ')}`);
  }
  return {
    includeAllIssues: cli.flags['all'],
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    reportId,
    strict: cli.flags['strict']
  };
}
const MAX_TIMEOUT_RETRY = 5;
async function fetchReportData(reportId, {
  includeAllIssues,
  strict
}) {
  // Do the API call
  const socketSdk = await (0, _sdk$g.setupSdk)();
  const spinner = _yoctoSpinner$g({
    text: `Fetching report with ID ${reportId} (this could take a while)`
  }).start();
  let result;
  for (let retry = 1; !result; ++retry) {
    try {
      // eslint-disable-next-line no-await-in-loop
      result = await (0, _apiHelpers$g.handleApiCall)(socketSdk.getReport(reportId), 'fetching report');
    } catch (err) {
      if (retry >= MAX_TIMEOUT_RETRY || !(err instanceof _ponyCause$3.ErrorWithCause) || err.cause?.cause?.response?.statusCode !== 524) {
        throw err;
      }
    }
  }
  if (result.success === false) {
    return (0, _apiHelpers$g.handleUnsuccessfulApiResponse)('getReport', result, spinner);
  }

  // Conclude the status of the API call

  if (strict) {
    if (result.data.healthy) {
      spinner.success('Report result is healthy and great!');
    } else {
      spinner.error('Report result deemed unhealthy for project');
    }
  } else if (result.data.healthy === false) {
    const severityCount = (0, _formatIssues.getSeverityCount)(result.data.issues, includeAllIssues ? undefined : 'high');
    const issueSummary = (0, _formatIssues.formatSeverityCount)(severityCount);
    spinner.success(`Report has these issues: ${issueSummary}`);
  } else {
    spinner.success('Report has no issues');
  }
  return result.data;
}
function formatReportDataOutput(data, {
  name,
  outputJson,
  outputMarkdown,
  reportId,
  strict
}) {
  if (outputJson) {
    console.log(JSON.stringify(data, undefined, 2));
  } else {
    const format = new _colorOrMarkdown$2.ColorOrMarkdown(!!outputMarkdown);
    console.log('\nDetailed info on socket.dev: ' + format.hyperlink(reportId, data.url, {
      fallbackToUrl: true
    }));
    if (!outputMarkdown) {
      console.log(_yoctocolorsCjs$f.dim(`\nOr rerun ${_yoctocolorsCjs$f.italic(name)} using the ${_yoctocolorsCjs$f.italic('--json')} flag to get full JSON output`));
    }
  }
  if (strict && data.healthy === false) {
    process.exit(1);
  }
}

var _interopRequireDefault$i = require$$0$1.default;
Object.defineProperty(create$5, "__esModule", {
  value: true
});
create$5.create = void 0;
var _nodePath = require$$1;
var _betterAjvErrors = require$$2$2;
var _meow$h = _interopRequireDefault$i(require$$2);
var _yoctoSpinner$f = require$$3;
var _ponyCause$2 = require$$4$1;
var _config = require$$6;
var _view$2 = view$3;
var _flags$f = flags$1;
var _apiHelpers$f = apiHelpers;
var _colorOrMarkdown$1 = sdk.colorOrMarkdown;
var _errors$g = sdk.errors;
var _formatting$g = formatting;
var _misc$1 = sdk.misc;
var _pathResolve$1 = pathResolve.pathResolve;
var _sdk$f = sdk.sdk;
const create$4 = create$5.create = {
  description: 'Create a project report',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} create`;
    const input = await setupCommand$g(name, create$4.description, argv, importMeta);
    if (input) {
      const {
        config,
        cwd,
        debugLog,
        dryRun,
        includeAllIssues,
        outputJson,
        outputMarkdown,
        packagePaths,
        strict,
        view
      } = input;
      const result = input && (await createReport(packagePaths, {
        config,
        cwd,
        debugLog,
        dryRun
      }));
      if (result && view) {
        const reportId = result.data.id;
        const reportData = input && (await (0, _view$2.fetchReportData)(reportId, {
          includeAllIssues,
          strict
        }));
        if (reportData) {
          (0, _view$2.formatReportDataOutput)(reportData, {
            includeAllIssues,
            name,
            outputJson,
            outputMarkdown,
            reportId,
            strict
          });
        }
      } else if (result) {
        formatReportCreationOutput(result.data, {
          outputJson,
          outputMarkdown
        });
      }
    }
  }
};

// Internal functions

async function setupCommand$g(name, description, argv, importMeta) {
  const flags = {
    ..._flags$f.commonFlags,
    ..._flags$f.outputFlags,
    ..._flags$f.validationFlags,
    debug: {
      type: 'boolean',
      shortFlag: 'd',
      default: false,
      description: 'Output debug information'
    },
    dryRun: {
      type: 'boolean',
      default: false,
      description: 'Only output what will be done without actually doing it'
    },
    view: {
      type: 'boolean',
      shortFlag: 'v',
      default: false,
      description: 'Will wait for and return the created report'
    }
  };
  const cli = (0, _meow$h.default)(`
    Usage
      $ ${name} <paths-to-package-folders-and-files>

    Uploads the specified "package.json" and lock files for JavaScript, Python, and Go dependency manifests.
    If any folder is specified, the ones found in there recursively are uploaded.

    Supports globbing such as "**/package.json", "**/requirements.txt", "**/pyproject.toml", and "**/go.mod".

    Ignores any file specified in your project's ".gitignore", your project's
    "socket.yml" file's "projectIgnorePaths" and also has a sensible set of
    default ignores from the "ignore-by-default" module.

    Options
      ${(0, _formatting$g.printFlagList)({
    all: 'Include all issues',
    debug: 'Output debug information',
    'dry-run': 'Only output what will be done without actually doing it',
    json: 'Output result as json',
    markdown: 'Output result as markdown',
    strict: 'Exits with an error code if any matching issues are found',
    view: 'Will wait for and return the created report'
  }, 6)}

    Examples
      $ ${name} .
      $ ${name} '**/package.json'
      $ ${name} /path/to/a/package.json /path/to/another/package.json
      $ ${name} . --view --json
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    dryRun
  } = cli.flags;
  const debugLog = (0, _misc$1.createDebugLogger)(!dryRun || cli.flags['debug']);

  // TODO: Allow setting a custom cwd and/or configFile path?
  const cwd = process.cwd();
  const absoluteConfigPath = _nodePath.join(cwd, 'socket.yml');
  const config = await (0, _config.readSocketConfig)(absoluteConfigPath).catch(cause => {
    if (cause && typeof cause === 'object' && cause instanceof _config.SocketValidationError) {
      // Inspired by workbox-build:
      // https://github.com/GoogleChrome/workbox/blob/95f97a207fd51efb3f8a653f6e3e58224183a778/packages/workbox-build/src/lib/validate-options.ts#L68-L71
      const betterErrors = (0, _betterAjvErrors.betterAjvErrors)({
        basePath: 'config',
        data: cause.data,
        errors: cause.validationErrors,
        schema: cause.schema
      });
      throw new _errors$g.InputError('The socket.yml config is not valid', betterErrors.map(err => `[${err.path}] ${err.message}.${err.suggestion ? err.suggestion : ''}`).join('\n'));
    } else {
      throw new _ponyCause$2.ErrorWithCause('Failed to read socket.yml config', {
        cause
      });
    }
  });
  const socketSdk = await (0, _sdk$f.setupSdk)();
  const supportedFiles = await socketSdk.getReportSupportedFiles().then(res => {
    if (!res.success) (0, _apiHelpers$f.handleUnsuccessfulApiResponse)('getReportSupportedFiles', res, _yoctoSpinner$f());
    return res.data;
  }).catch(cause => {
    throw new _ponyCause$2.ErrorWithCause('Failed getting supported files for report', {
      cause
    });
  });
  const packagePaths = await (0, _pathResolve$1.getPackageFiles)(cwd, cli.input, config, supportedFiles, debugLog);
  return {
    config,
    cwd,
    debugLog,
    dryRun,
    includeAllIssues: cli.flags['all'],
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    packagePaths,
    strict: cli.flags['strict'],
    view: cli.flags['view']
  };
}
async function createReport(packagePaths, {
  config,
  cwd,
  debugLog,
  dryRun
}) {
  debugLog('Uploading:', packagePaths.join(`\n${_colorOrMarkdown$1.logSymbols.info} Uploading: `));
  if (dryRun) {
    return;
  }
  const socketSdk = await (0, _sdk$f.setupSdk)();
  const spinner = _yoctoSpinner$f({
    text: `Creating report with ${packagePaths.length} package files`
  }).start();
  const apiCall = socketSdk.createReportFromFilePaths(packagePaths, cwd, config?.issueRules);
  const result = await (0, _apiHelpers$f.handleApiCall)(apiCall, 'creating report');
  if (result.success) {
    spinner.success();
    return result;
  }
  (0, _apiHelpers$f.handleUnsuccessfulApiResponse)('createReport', result, spinner);
  return undefined;
}
function formatReportCreationOutput(data, {
  outputJson,
  outputMarkdown
}) {
  if (outputJson) {
    console.log(JSON.stringify(data, undefined, 2));
    return;
  }
  const format = new _colorOrMarkdown$1.ColorOrMarkdown(!!outputMarkdown);
  console.log(`New report: ${format.hyperlink(data.id, data.url, {
    fallbackToUrl: true
  })}`);
}

var meowWithSubcommands$1 = {};

var _interopRequireDefault$h = require$$0$1.default;
Object.defineProperty(meowWithSubcommands$1, "__esModule", {
  value: true
});
meowWithSubcommands$1.meowWithSubcommands = meowWithSubcommands;
var _meow$g = _interopRequireDefault$h(require$$2);
var _objects = require$$7;
var _formatting$f = formatting;
var _flags$e = flags$1;
async function meowWithSubcommands(subcommands, options) {
  const {
    aliases = {},
    argv,
    importMeta,
    name,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const [commandOrAliasName, ...rawCommandArgv] = argv;
  // If we got at least some args, then lets find out if we can find a command
  if (commandOrAliasName) {
    const alias = aliases[commandOrAliasName];
    // First: Resolve argv data from alias if its an alias that's been given
    const [commandName, ...commandArgv] = alias ? [...alias.argv, ...rawCommandArgv] : [commandOrAliasName, ...rawCommandArgv];
    // Second: Find a command definition using that data
    const commandDefinition = commandName ? subcommands[commandName] : undefined;
    // Third: If a valid command has been found, then we run it...
    if (commandDefinition) {
      return await commandDefinition.run(commandArgv, importMeta, {
        parentName: name
      });
    }
  }
  const flags = {
    ..._flags$e.commonFlags,
    ...additionalOptions.flags
  };
  // ...else we provide basic instructions and help
  const cli = (0, _meow$g.default)(`
    Usage
      $ ${name} <command>

    Commands
      ${(0, _formatting$f.printHelpList)({
    ...(0, _objects.toSortedObject)(subcommands),
    ...(0, _objects.toSortedObject)(aliases)
  }, 6)}

    Options
      ${(0, _formatting$f.printFlagList)(flags, 6)}

    Examples
      $ ${name} --help
  `, {
    argv,
    importMeta,
    ...additionalOptions,
    flags
  });
  cli.showHelp();
}

Object.defineProperty(report, "__esModule", {
  value: true
});
report.report = void 0;
var _create$2 = create$5;
var _view$1 = view$3;
var _meowWithSubcommands$4 = meowWithSubcommands$1;
const description$3 = '[Deprecated] Project report related commands';
report.report = {
  description: description$3,
  async run(argv, importMeta, {
    parentName
  }) {
    await (0, _meowWithSubcommands$4.meowWithSubcommands)({
      create: _create$2.create,
      view: _view$1.view
    }, {
      argv,
      description: description$3,
      importMeta,
      name: parentName + ' report'
    });
  }
};

var wrapper$1 = {};

var _interopRequireDefault$g = require$$0$1.default;
Object.defineProperty(wrapper$1, "__esModule", {
  value: true
});
wrapper$1.wrapper = void 0;
var _nodeFs$1 = require$$0;
var _nodeOs = require$$2$3;
var _nodeReadline = require$$3$4;
var _meow$f = _interopRequireDefault$g(require$$2);
var _flags$d = flags$1;
var _formatting$e = formatting;
const BASH_FILE = `${_nodeOs.homedir()}/.bashrc`;
const ZSH_BASH_FILE = `${_nodeOs.homedir()}/.zshrc`;
const wrapper = wrapper$1.wrapper = {
  description: 'Enable or disable the Socket npm/npx wrapper',
  async run(argv, importMeta, {
    parentName
  }) {
    setupCommand$f(`${parentName} wrapper`, wrapper.description, argv, importMeta);
  }
};
function setupCommand$f(name, description, argv, importMeta) {
  const flags = _flags$d.commandFlags;
  const cli = (0, _meow$f.default)(`
    Usage
      $ ${name} <flag>

    Options
      ${(0, _formatting$e.printFlagList)(flags, 6)}

    Examples
      $ ${name} --enable
      $ ${name} --disable
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  if (argv[0] === '--postinstall') {
    const socketWrapperEnabled = _nodeFs$1.existsSync(BASH_FILE) && checkSocketWrapperAlreadySetup(BASH_FILE) || _nodeFs$1.existsSync(ZSH_BASH_FILE) && checkSocketWrapperAlreadySetup(ZSH_BASH_FILE);
    if (!socketWrapperEnabled) {
      installSafeNpm(`The Socket CLI is now successfully installed! 🎉

      To better protect yourself against supply-chain attacks, our "safe npm" wrapper can warn you about malicious packages whenever you run 'npm install'.

      Do you want to install "safe npm" (this will create an alias to the socket-npm command)? (y/n)`);
    }
    return;
  }
  const {
    disable,
    enable
  } = cli.flags;
  let showHelp = cli.flags['help'];
  if (!enable && !disable) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  if (enable) {
    if (_nodeFs$1.existsSync(BASH_FILE)) {
      const socketWrapperEnabled = checkSocketWrapperAlreadySetup(BASH_FILE);
      !socketWrapperEnabled && addAlias(BASH_FILE);
    }
    if (_nodeFs$1.existsSync(ZSH_BASH_FILE)) {
      const socketWrapperEnabled = checkSocketWrapperAlreadySetup(ZSH_BASH_FILE);
      !socketWrapperEnabled && addAlias(ZSH_BASH_FILE);
    }
  } else if (disable) {
    if (_nodeFs$1.existsSync(BASH_FILE)) {
      removeAlias(BASH_FILE);
    }
    if (_nodeFs$1.existsSync(ZSH_BASH_FILE)) {
      removeAlias(ZSH_BASH_FILE);
    }
  }
  if (!_nodeFs$1.existsSync(BASH_FILE) && !_nodeFs$1.existsSync(ZSH_BASH_FILE)) {
    console.error('There was an issue setting up the alias in your bash profile');
  }
}
const installSafeNpm = query => {
  console.log(`
 _____         _       _
|   __|___ ___| |_ ___| |_
|__   | . |  _| '_| -_|  _|
|_____|___|___|_,_|___|_|

`);
  const rl = _nodeReadline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return askQuestion(rl, query);
};
const askQuestion = (rl, query) => {
  rl.question(query, ans => {
    if (ans.toLowerCase() === 'y') {
      try {
        if (_nodeFs$1.existsSync(BASH_FILE)) {
          addAlias(BASH_FILE);
        }
        if (_nodeFs$1.existsSync(ZSH_BASH_FILE)) {
          addAlias(ZSH_BASH_FILE);
        }
      } catch (e) {
        throw new Error(`There was an issue setting up the alias: ${e}`);
      }
      rl.close();
    } else if (ans.toLowerCase() !== 'n') {
      askQuestion(rl, 'Incorrect input: please enter either y (yes) or n (no): ');
    } else {
      rl.close();
    }
  });
};
const addAlias = file => {
  return _nodeFs$1.appendFile(file, 'alias npm="socket npm"\nalias npx="socket npx"\n', err => {
    if (err) {
      return new Error(`There was an error setting up the alias: ${err}`);
    }
    console.log(`
The alias was added to ${file}. Running 'npm install' will now be wrapped in Socket's "safe npm" 🎉
If you want to disable it at any time, run \`socket wrapper --disable\`
`);
  });
};
const removeAlias = file => {
  return _nodeFs$1.readFile(file, 'utf8', function (err, data) {
    if (err) {
      console.error(`There was an error removing the alias: ${err}`);
      return;
    }
    const linesWithoutSocketAlias = data.split('\n').filter(l => l !== 'alias npm="socket npm"' && l !== 'alias npx="socket npx"');
    const updatedFileContent = linesWithoutSocketAlias.join('\n');
    _nodeFs$1.writeFile(file, updatedFileContent, function (err) {
      if (err) {
        console.log(err);
        return;
      } else {
        console.log(`\nThe alias was removed from ${file}. Running 'npm install' will now run the standard npm command.\n`);
      }
    });
  });
};
const checkSocketWrapperAlreadySetup = file => {
  const fileContent = _nodeFs$1.readFileSync(file, 'utf-8');
  const linesWithSocketAlias = fileContent.split('\n').filter(l => l === 'alias npm="socket npm"' || l === 'alias npx="socket npx"');
  if (linesWithSocketAlias.length) {
    console.log(`The Socket npm/npx wrapper is set up in your bash profile (${file}).`);
    return true;
  }
  return false;
};

var scan = {};

var create$3 = {};

var _interopRequireDefault$f = require$$0$1.default;
Object.defineProperty(create$3, "__esModule", {
  value: true
});
create$3.create = void 0;
var _nodeProcess = require$$1$5;
var _promises$1 = require$$2$4;
var _yoctocolorsCjs$e = require$$1$2;
var _meow$e = _interopRequireDefault$f(require$$2);
var _open = _interopRequireDefault$f(require$$5$3);
var _yoctoSpinner$e = require$$3;
var _ponyCause$1 = require$$4$1;
var _apiHelpers$e = apiHelpers;
var _errors$f = sdk.errors;
var _formatting$d = formatting;
var _misc = sdk.misc;
var _pathResolve = pathResolve.pathResolve;
var _sdk$e = sdk.sdk;
const create$2 = create$3.create = {
  description: 'Create a scan',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} create`;
    const input = await setupCommand$e(name, create$2.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$e.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$f.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Creating a scan... \n';
      const spinner = _yoctoSpinner$e({
        text: spinnerText
      }).start();
      await createFullScan(input, spinner, apiKey);
    }
  }
};
const createFullScanFlags = {
  repo: {
    type: 'string',
    shortFlag: 'r',
    default: '',
    description: 'Repository name'
  },
  branch: {
    type: 'string',
    shortFlag: 'b',
    default: '',
    description: 'Branch name'
  },
  commitMessage: {
    type: 'string',
    shortFlag: 'm',
    default: '',
    description: 'Commit message'
  },
  commitHash: {
    type: 'string',
    shortFlag: 'ch',
    default: '',
    description: 'Commit hash'
  },
  pullRequest: {
    type: 'number',
    shortFlag: 'pr',
    description: 'Commit hash'
  },
  committers: {
    type: 'string',
    shortFlag: 'c',
    default: '',
    description: 'Committers'
  },
  defaultBranch: {
    type: 'boolean',
    shortFlag: 'db',
    default: false,
    description: 'Make default branch'
  },
  pendingHead: {
    type: 'boolean',
    shortFlag: 'ph',
    default: false,
    description: 'Set as pending head'
  },
  tmp: {
    type: 'boolean',
    shortFlag: 't',
    default: false,
    description: 'Set the visibility (true/false) of the scan in your dashboard'
  }
};

// Internal functions

async function setupCommand$e(name, description, argv, importMeta) {
  const flags = {
    ...createFullScanFlags
  };
  const cli = (0, _meow$e.default)(`
    Usage
      $ ${name} [...options]

    Options
      ${(0, _formatting$d.printFlagList)(flags, 6)}

    Examples
      $ ${name} --org=FakeOrg --repo=test-repo --branch=main ./package.json
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = ''
  } = cli.input;
  const cwd = process.cwd();
  const socketSdk = await (0, _sdk$e.setupSdk)();
  const supportedFiles = await socketSdk.getReportSupportedFiles().then(res => {
    if (!res.success) (0, _apiHelpers$e.handleUnsuccessfulApiResponse)('getReportSupportedFiles', res, _yoctoSpinner$e());
    return res.data;
  }).catch(/** @type {(cause: Error) => never} */
  cause => {
    throw new _ponyCause$1.ErrorWithCause('Failed getting supported files for report', {
      cause
    });
  });
  const debugLog = (0, _misc.createDebugLogger)(false);
  const packagePaths = await (0, _pathResolve.getPackageFilesFullScans)(cwd, cli.input, supportedFiles, debugLog);
  const {
    branch: branchName,
    repo: repoName
  } = cli.flags;
  if (!repoName || !branchName || !packagePaths.length) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$e.bgRed(_yoctocolorsCjs$e.white('Input error'))}: Please provide the required fields:\n
    - Repository name using --repo\n
    - Branch name using --branch\n
    - At least one file path (e.g. ./package.json)`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    orgSlug,
    repoName,
    branchName,
    commitMessage: cli.flags['commitMessage'],
    defaultBranch: cli.flags['defaultBranch'],
    pendingHead: cli.flags['pendingHead'],
    tmp: cli.flags['tmp'],
    packagePaths,
    commitHash: cli.flags['commitHash'],
    committers: cli.flags['committers'],
    pullRequest: cli.flags['pullRequest']
  };
}
async function createFullScan(input, spinner, apiKey) {
  const socketSdk = await (0, _sdk$e.setupSdk)(apiKey);
  const {
    branchName,
    commitMessage,
    defaultBranch,
    orgSlug,
    packagePaths,
    pendingHead,
    repoName,
    tmp
  } = input;
  const result = await (0, _apiHelpers$e.handleApiCall)(socketSdk.createOrgFullScan(orgSlug, {
    repo: repoName,
    branch: branchName,
    commit_message: commitMessage,
    make_default_branch: defaultBranch,
    set_as_pending_head: pendingHead,
    tmp
  }, packagePaths), 'Creating scan');
  if (!result.success) {
    (0, _apiHelpers$e.handleUnsuccessfulApiResponse)('CreateOrgFullScan', result, spinner);
    return;
  }
  spinner.success('Scan created successfully');
  const link = _yoctocolorsCjs$e.underline(_yoctocolorsCjs$e.cyan(`${result.data.html_report_url}`));
  console.log(`Available at: ${link}`);
  const rl = _promises$1.createInterface({
    input: _nodeProcess.stdin,
    output: _nodeProcess.stdout
  });
  const answer = await rl.question('Would you like to open it in your browser? (y/n)');
  if (answer.toLowerCase() === 'y') {
    await (0, _open.default)(`${result.data.html_report_url}`);
  }
  rl.close();
}

var _delete$3 = {};

var _interopRequireDefault$e = require$$0$1.default;
Object.defineProperty(_delete$3, "__esModule", {
  value: true
});
_delete$3.del = void 0;
var _yoctocolorsCjs$d = require$$1$2;
var _meow$d = _interopRequireDefault$e(require$$2);
var _yoctoSpinner$d = require$$3;
var _flags$c = flags$1;
var _apiHelpers$d = apiHelpers;
var _errors$e = sdk.errors;
var _formatting$c = formatting;
var _sdk$d = sdk.sdk;
const del$1 = _delete$3.del = {
  description: 'Delete a scan',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} del`;
    const input = setupCommand$d(name, del$1.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$d.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$e.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Deleting scan...';
      const spinner = _yoctoSpinner$d({
        text: spinnerText
      }).start();
      await deleteOrgFullScan(input.orgSlug, input.fullScanId, spinner, apiKey);
    }
  }
};

// Internal functions

function setupCommand$d(name, description, argv, importMeta) {
  const flags = {
    ..._flags$c.commonFlags,
    ..._flags$c.outputFlags
  };
  const cli = (0, _meow$d.default)(`
    Usage
      $ ${name} <org slug> <scan ID>

    Options
      ${(0, _formatting$c.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeOrg 000aaaa1-0000-0a0a-00a0-00a0000000a0
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (cli.input.length < 2) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$d.bgRed(_yoctocolorsCjs$d.white('Input error'))}: Please specify an organization slug and a scan ID.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = '',
    1: fullScanId = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    fullScanId
  };
}
async function deleteOrgFullScan(orgSlug, fullScanId, spinner, apiKey) {
  const socketSdk = await (0, _sdk$d.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$d.handleApiCall)(socketSdk.deleteOrgFullScan(orgSlug, fullScanId), 'Deleting scan');
  if (result.success) {
    spinner.success('Scan deleted successfully');
  } else {
    (0, _apiHelpers$d.handleUnsuccessfulApiResponse)('deleteOrgFullScan', result, spinner);
  }
}

var list$3 = {};

var _interopRequireDefault$d = require$$0$1.default;
Object.defineProperty(list$3, "__esModule", {
  value: true
});
list$3.list = void 0;
var _yoctocolorsCjs$c = require$$1$2;
var _chalkTable$3 = require$$2$5;
var _meow$c = _interopRequireDefault$d(require$$2);
var _yoctoSpinner$c = require$$3;
var _flags$b = flags$1;
var _apiHelpers$c = apiHelpers;
var _errors$d = sdk.errors;
var _formatting$b = formatting;
var _sdk$c = sdk.sdk;
// @ts-ignore

const list$2 = list$3.list = {
  description: 'List scans for an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} list`;
    const input = setupCommand$c(name, list$2.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$c.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$d.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Listing scans... \n';
      const spinner = _yoctoSpinner$c({
        text: spinnerText
      }).start();
      await listOrgFullScan(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const listFullScanFlags = {
  sort: {
    type: 'string',
    shortFlag: 's',
    default: 'created_at',
    description: 'Sorting option (`name` or `created_at`) - default is `created_at`'
  },
  direction: {
    type: 'string',
    shortFlag: 'd',
    default: 'desc',
    description: 'Direction option (`desc` or `asc`) - Default is `desc`'
  },
  perPage: {
    type: 'number',
    shortFlag: 'pp',
    default: 30,
    description: 'Results per page - Default is 30'
  },
  page: {
    type: 'number',
    shortFlag: 'p',
    default: 1,
    description: 'Page number - Default is 1'
  },
  fromTime: {
    type: 'string',
    shortFlag: 'f',
    default: '',
    description: 'From time - as a unix timestamp'
  },
  untilTime: {
    type: 'string',
    shortFlag: 'u',
    default: '',
    description: 'Until time - as a unix timestamp'
  }
};

// Internal functions

function setupCommand$c(name, description, argv, importMeta) {
  const flags = {
    ..._flags$b.commonFlags,
    ...listFullScanFlags,
    ..._flags$b.outputFlags
  };
  const cli = (0, _meow$c.default)(`
    Usage
      $ ${name} <org slug>

    Options
      ${(0, _formatting$b.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$c.bgRed(_yoctocolorsCjs$c.white('Input error'))}: Please specify an organization slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    sort: cli.flags['sort'],
    direction: cli.flags['direction'],
    per_page: cli.flags['perPage'],
    page: cli.flags['page'],
    from_time: cli.flags['fromTime'],
    until_time: cli.flags['untilTime']
  };
}
async function listOrgFullScan(orgSlug, input, spinner, apiKey) {
  const socketSdk = await (0, _sdk$c.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$c.handleApiCall)(socketSdk.getOrgFullScanList(orgSlug, input), 'Listing scans');
  if (!result.success) {
    (0, _apiHelpers$c.handleUnsuccessfulApiResponse)('getOrgFullScanList', result, spinner);
    return;
  }
  const options = {
    columns: [{
      field: 'id',
      name: _yoctocolorsCjs$c.magenta('ID')
    }, {
      field: 'report_url',
      name: _yoctocolorsCjs$c.magenta('Scan URL')
    }, {
      field: 'branch',
      name: _yoctocolorsCjs$c.magenta('Branch')
    }, {
      field: 'created_at',
      name: _yoctocolorsCjs$c.magenta('Created at')
    }]
  };
  const formattedResults = result.data.results.map(d => {
    return {
      id: d.id,
      report_url: _yoctocolorsCjs$c.underline(`${d.html_report_url}`),
      created_at: d.created_at ? new Date(d.created_at).toLocaleDateString('en-us', {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
      }) : '',
      branch: d.branch
    };
  });
  spinner.stop(`Listing scans for: ${orgSlug}`);
  console.log(_chalkTable$3(options, formattedResults));
}

var metadata$1 = {};

var _interopRequireDefault$c = require$$0$1.default;
Object.defineProperty(metadata$1, "__esModule", {
  value: true
});
metadata$1.metadata = void 0;
var _yoctocolorsCjs$b = require$$1$2;
var _meow$b = _interopRequireDefault$c(require$$2);
var _yoctoSpinner$b = require$$3;
var _flags$a = flags$1;
var _apiHelpers$b = apiHelpers;
var _errors$c = sdk.errors;
var _formatting$a = formatting;
var _sdk$b = sdk.sdk;
const metadata = metadata$1.metadata = {
  description: "Get a scan's metadata",
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} metadata`;
    const input = setupCommand$b(name, metadata.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$b.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$c.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = "Getting scan's metadata... \n";
      const spinner = _yoctoSpinner$b({
        text: spinnerText
      }).start();
      await getOrgScanMetadata(input.orgSlug, input.scanID, spinner, apiKey);
    }
  }
};

// Internal functions

function setupCommand$b(name, description, argv, importMeta) {
  const flags = {
    ..._flags$a.commonFlags,
    ..._flags$a.outputFlags
  };
  const cli = (0, _meow$b.default)(`
    Usage
      $ ${name} <org slug> <scan id>

    Options
      ${(0, _formatting$a.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeOrg 000aaaa1-0000-0a0a-00a0-00a0000000a0
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (cli.input.length < 2) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$b.bgRed(_yoctocolorsCjs$b.white('Input error'))}: Please specify an organization slug and a scan ID.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = '',
    1: scanID = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    scanID
  };
}
async function getOrgScanMetadata(orgSlug, scanId, spinner, apiKey) {
  const socketSdk = await (0, _sdk$b.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$b.handleApiCall)(socketSdk.getOrgFullScanMetadata(orgSlug, scanId), 'Listing scans');
  if (!result.success) {
    (0, _apiHelpers$b.handleUnsuccessfulApiResponse)('getOrgFullScanMetadata', result, spinner);
    return;
  }
  spinner.stop('Scan metadata:');
  console.log(result.data);
}

var stream$1 = {};

var _interopRequireDefault$b = require$$0$1.default;
Object.defineProperty(stream$1, "__esModule", {
  value: true
});
stream$1.stream = void 0;
var _yoctocolorsCjs$a = require$$1$2;
var _meow$a = _interopRequireDefault$b(require$$2);
var _yoctoSpinner$a = require$$3;
var _flags$9 = flags$1;
var _apiHelpers$a = apiHelpers;
var _errors$b = sdk.errors;
var _formatting$9 = formatting;
var _sdk$a = sdk.sdk;
const stream = stream$1.stream = {
  description: 'Stream the output of a scan',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} stream`;
    const input = setupCommand$a(name, stream.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$a.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$b.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinner = _yoctoSpinner$a({
        text: 'Streaming scan...'
      }).start();
      const result = await getOrgFullScan(input.orgSlug, input.fullScanId, input.file, apiKey);
      if (result?.success) {
        spinner.stop(input.file ? `Full scan details written to ${input.file}` : '');
      } else {
        (0, _apiHelpers$a.handleUnsuccessfulApiResponse)('getOrgFullScan', result, spinner);
      }
    }
  }
};

// Internal functions

function setupCommand$a(name, description, argv, importMeta) {
  const flags = {
    ..._flags$9.commonFlags,
    ..._flags$9.outputFlags
  };
  const cli = (0, _meow$a.default)(`
    Usage
      $ ${name} <org slug> <scan ID> <path to output file>

    Options
      ${(0, _formatting$9.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeOrg 000aaaa1-0000-0a0a-00a0-00a0000000a0 ./stream.txt
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (cli.input.length < 2) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$a.bgRed(_yoctocolorsCjs$a.white('Input error'))}: Please specify an organization slug and a scan ID.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = '',
    1: fullScanId = '',
    2: file
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    fullScanId,
    file
  };
}
async function getOrgFullScan(orgSlug, fullScanId, file, apiKey) {
  const socketSdk = await (0, _sdk$a.setupSdk)(apiKey);
  return await (0, _apiHelpers$a.handleApiCall)(socketSdk.getOrgFullScan(orgSlug, fullScanId, file), 'Streaming a scan');
}

Object.defineProperty(scan, "__esModule", {
  value: true
});
scan.scan = void 0;
var _create$1 = create$3;
var _delete$2 = _delete$3;
var _list$1 = list$3;
var _metadata = metadata$1;
var _stream = stream$1;
var _meowWithSubcommands$3 = meowWithSubcommands$1;
const description$2 = 'Scans related commands';
scan.scan = {
  description: description$2,
  async run(argv, importMeta, {
    parentName
  }) {
    await (0, _meowWithSubcommands$3.meowWithSubcommands)({
      create: _create$1.create,
      stream: _stream.stream,
      list: _list$1.list,
      del: _delete$2.del,
      metadata: _metadata.metadata
    }, {
      argv,
      description: description$2,
      importMeta,
      name: parentName + ' scan'
    });
  }
};

var auditLog$1 = {};

var _interopRequireDefault$a = require$$0$1.default;
Object.defineProperty(auditLog$1, "__esModule", {
  value: true
});
auditLog$1.auditLog = void 0;
var _prompts = require$$1$3;
var _yoctocolorsCjs$9 = require$$1$2;
var _meow$9 = _interopRequireDefault$a(require$$2);
var _yoctoSpinner$9 = require$$3;
var _flags$8 = flags$1;
var _apiHelpers$9 = apiHelpers;
var _errors$a = sdk.errors;
var _formatting$8 = formatting;
var _sdk$9 = sdk.sdk;
const auditLog = auditLog$1.auditLog = {
  description: 'Look up the audit log for an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = parentName + ' audit-log';
    const input = setupCommand$9(name, auditLog.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$9.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$a.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinner = _yoctoSpinner$9({
        text: `Looking up audit log for ${input.orgSlug}\n`
      }).start();
      await fetchOrgAuditLog(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const auditLogFlags = {
  type: {
    type: 'string',
    shortFlag: 't',
    default: '',
    description: 'Type of log event'
  },
  perPage: {
    type: 'number',
    shortFlag: 'pp',
    default: 30,
    description: 'Results per page - default is 30'
  },
  page: {
    type: 'number',
    shortFlag: 'p',
    default: 1,
    description: 'Page number - default is 1'
  }
};

// Internal functions

function setupCommand$9(name, description, argv, importMeta) {
  const flags = {
    ...auditLogFlags,
    ..._flags$8.commonFlags,
    ..._flags$8.outputFlags
  };
  const cli = (0, _meow$9.default)(`
    Usage
      $ ${name} <org slug>

    Options
      ${(0, _formatting$8.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (cli.input.length < 1) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$9.bgRed(_yoctocolorsCjs$9.white('Input error'))}: Please provide an organization slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    json: outputJson,
    markdown: outputMarkdown,
    page,
    perPage
  } = cli.flags;
  const type = cli.flags['type'];
  const {
    0: orgSlug = ''
  } = cli.input;
  return {
    outputJson,
    outputMarkdown,
    orgSlug,
    type: type && type.charAt(0).toUpperCase() + type.slice(1),
    page,
    per_page: perPage
  };
}
async function fetchOrgAuditLog(orgSlug, input, spinner, apiKey) {
  const socketSdk = await (0, _sdk$9.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$9.handleApiCall)(socketSdk.getAuditLogEvents(orgSlug, input), `Looking up audit log for ${orgSlug}\n`);
  if (!result.success) {
    (0, _apiHelpers$9.handleUnsuccessfulApiResponse)('getAuditLogEvents', result, spinner);
    return;
  }
  spinner.stop();
  const data = [];
  const logDetails = {};
  for (const d of result.data.results) {
    const {
      created_at
    } = d;
    if (created_at) {
      const name = `${new Date(created_at).toLocaleDateString('en-us', {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
      })} - ${d.user_email} - ${d.type} - ${d.ip_address} - ${d.user_agent}`;
      data.push({
        name
      }, new _prompts.Separator());
      logDetails[name] = JSON.stringify(d.payload);
    }
  }
  console.log(logDetails[await (0, _prompts.select)({
    message: input.type ? `\n Audit log for: ${orgSlug} with type: ${input.type}\n` : `\n Audit log for: ${orgSlug}\n`,
    choices: data,
    pageSize: 30
  })]);
}

var repos = {};

var create$1 = {};

var _interopRequireDefault$9 = require$$0$1.default;
Object.defineProperty(create$1, "__esModule", {
  value: true
});
create$1.create = void 0;
var _yoctocolorsCjs$8 = require$$1$2;
var _meow$8 = _interopRequireDefault$9(require$$2);
var _yoctoSpinner$8 = require$$3;
var _flags$7 = flags$1;
var _apiHelpers$8 = apiHelpers;
var _errors$9 = sdk.errors;
var _formatting$7 = formatting;
var _sdk$8 = sdk.sdk;
const create = create$1.create = {
  description: 'Create a repository in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} create`;
    const input = setupCommand$8(name, create.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$8.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$9.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Creating repository... \n';
      const spinner = _yoctoSpinner$8({
        text: spinnerText
      }).start();
      await createRepo(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const repositoryCreationFlags = {
  repoName: {
    type: 'string',
    shortFlag: 'n',
    default: '',
    description: 'Repository name'
  },
  repoDescription: {
    type: 'string',
    shortFlag: 'd',
    default: '',
    description: 'Repository description'
  },
  homepage: {
    type: 'string',
    shortFlag: 'h',
    default: '',
    description: 'Repository url'
  },
  defaultBranch: {
    type: 'string',
    shortFlag: 'b',
    default: 'main',
    description: 'Repository default branch'
  },
  visibility: {
    type: 'string',
    shortFlag: 'v',
    default: 'private',
    description: 'Repository visibility (Default Private)'
  }
};

// Internal functions

function setupCommand$8(name, description, argv, importMeta) {
  const flags = {
    ..._flags$7.commonFlags,
    ..._flags$7.outputFlags,
    ...repositoryCreationFlags
  };
  const cli = (0, _meow$8.default)(`
    Usage
      $ ${name} <org slug>

    Options
      ${(0, _formatting$7.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeOrg --repoName=test-repo
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    repoName
  } = cli.flags;
  const [orgSlug = ''] = cli.input;
  let showHelp = cli.flags['help'];
  if (!orgSlug) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$8.bgRed(_yoctocolorsCjs$8.white('Input error'))}: Please provide an organization slug.`);
  } else if (!repoName) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$8.bgRed(_yoctocolorsCjs$8.white('Input error'))}: Repository name is required.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    name: repoName,
    description: cli.flags['repoDescription'],
    homepage: cli.flags['homepage'],
    default_branch: cli.flags['defaultBranch'],
    visibility: cli.flags['visibility']
  };
}
async function createRepo(orgSlug, input, spinner, apiKey) {
  const socketSdk = await (0, _sdk$8.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$8.handleApiCall)(socketSdk.createOrgRepo(orgSlug, input), 'creating repository');
  if (result.success) {
    spinner.success('Repository created successfully');
  } else {
    (0, _apiHelpers$8.handleUnsuccessfulApiResponse)('createOrgRepo', result, spinner);
  }
}

var _delete$1 = {};

var _interopRequireDefault$8 = require$$0$1.default;
Object.defineProperty(_delete$1, "__esModule", {
  value: true
});
_delete$1.del = void 0;
var _yoctocolorsCjs$7 = require$$1$2;
var _meow$7 = _interopRequireDefault$8(require$$2);
var _yoctoSpinner$7 = require$$3;
var _apiHelpers$7 = apiHelpers;
var _errors$8 = sdk.errors;
var _sdk$7 = sdk.sdk;
const del = _delete$1.del = {
  description: 'Delete a repository in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} del`;
    const input = setupCommand$7(name, del.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$7.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$8.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Deleting repository... \n';
      const spinner = _yoctoSpinner$7({
        text: spinnerText
      }).start();
      await deleteRepository(input.orgSlug, input.repoName, spinner, apiKey);
    }
  }
};

// Internal functions

function setupCommand$7(name, description, argv, importMeta) {
  const cli = (0, _meow$7.default)(`
    Usage
      $ ${name} <org slug> <repo slug>

    Examples
      $ ${name} FakeOrg test-repo
  `, {
    argv,
    description,
    importMeta
  });
  const {
    0: orgSlug = '',
    1: repoName = ''
  } = cli.input;
  let showHelp = cli.flags['help'];
  if (!orgSlug || !repoName) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$7.bgRed(_yoctocolorsCjs$7.white('Input error'))}: Please provide an organization slug and repository slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    orgSlug,
    repoName
  };
}
async function deleteRepository(orgSlug, repoName, spinner, apiKey) {
  const socketSdk = await (0, _sdk$7.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$7.handleApiCall)(socketSdk.deleteOrgRepo(orgSlug, repoName), 'deleting repository');
  if (result.success) {
    spinner.success('Repository deleted successfully');
  } else {
    (0, _apiHelpers$7.handleUnsuccessfulApiResponse)('deleteOrgRepo', result, spinner);
  }
}

var list$1 = {};

var _interopRequireDefault$7 = require$$0$1.default;
Object.defineProperty(list$1, "__esModule", {
  value: true
});
list$1.list = void 0;
var _yoctocolorsCjs$6 = require$$1$2;
var _chalkTable$2 = require$$2$5;
var _meow$6 = _interopRequireDefault$7(require$$2);
var _yoctoSpinner$6 = require$$3;
var _flags$6 = flags$1;
var _apiHelpers$6 = apiHelpers;
var _errors$7 = sdk.errors;
var _formatting$6 = formatting;
var _sdk$6 = sdk.sdk;
// @ts-ignore

const list = list$1.list = {
  description: 'List repositories in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} list`;
    const input = setupCommand$6(name, list.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$6.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$7.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Listing repositories... \n';
      const spinner = _yoctoSpinner$6({
        text: spinnerText
      }).start();
      await listOrgRepos(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const listRepoFlags = {
  sort: {
    type: 'string',
    shortFlag: 's',
    default: 'created_at',
    description: 'Sorting option'
  },
  direction: {
    type: 'string',
    default: 'desc',
    description: 'Direction option'
  },
  perPage: {
    type: 'number',
    shortFlag: 'pp',
    default: 30,
    description: 'Number of results per page'
  },
  page: {
    type: 'number',
    shortFlag: 'p',
    default: 1,
    description: 'Page number'
  }
};

// Internal functions

function setupCommand$6(name, description, argv, importMeta) {
  const flags = {
    ..._flags$6.commonFlags,
    ...listRepoFlags,
    ..._flags$6.outputFlags
  };
  const cli = (0, _meow$6.default)(`
    Usage
      $ ${name} <org slug>

    Options
      ${(0, _formatting$6.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$6.bgRed(_yoctocolorsCjs$6.white('Input error'))}: Please provide an organization slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    sort: cli.flags['sort'],
    direction: cli.flags['direction'],
    page: cli.flags['page'],
    per_page: cli.flags['perPage']
  };
}
async function listOrgRepos(orgSlug, input, spinner, apiKey) {
  const socketSdk = await (0, _sdk$6.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$6.handleApiCall)(socketSdk.getOrgRepoList(orgSlug, input), 'listing repositories');
  if (!result.success) {
    (0, _apiHelpers$6.handleUnsuccessfulApiResponse)('getOrgRepoList', result, spinner);
    return;
  }
  const options = {
    columns: [{
      field: 'id',
      name: _yoctocolorsCjs$6.magenta('ID')
    }, {
      field: 'name',
      name: _yoctocolorsCjs$6.magenta('Name')
    }, {
      field: 'visibility',
      name: _yoctocolorsCjs$6.magenta('Visibility')
    }, {
      field: 'default_branch',
      name: _yoctocolorsCjs$6.magenta('Default branch')
    }, {
      field: 'archived',
      name: _yoctocolorsCjs$6.magenta('Archived')
    }]
  };
  spinner.stop(_chalkTable$2(options, result.data.results));
}

var update$1 = {};

var _interopRequireDefault$6 = require$$0$1.default;
Object.defineProperty(update$1, "__esModule", {
  value: true
});
update$1.update = void 0;
var _yoctocolorsCjs$5 = require$$1$2;
var _meow$5 = _interopRequireDefault$6(require$$2);
var _yoctoSpinner$5 = require$$3;
var _flags$5 = flags$1;
var _apiHelpers$5 = apiHelpers;
var _errors$6 = sdk.errors;
var _formatting$5 = formatting;
var _sdk$5 = sdk.sdk;
const update = update$1.update = {
  description: 'Update a repository in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} update`;
    const input = setupCommand$5(name, update.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$5.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$6.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Updating repository... \n';
      const spinner = _yoctoSpinner$5({
        text: spinnerText
      }).start();
      await updateRepository(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const repositoryUpdateFlags = {
  repoName: {
    type: 'string',
    shortFlag: 'n',
    default: '',
    description: 'Repository name'
  },
  repoDescription: {
    type: 'string',
    shortFlag: 'd',
    default: '',
    description: 'Repository description'
  },
  homepage: {
    type: 'string',
    shortFlag: 'h',
    default: '',
    description: 'Repository url'
  },
  defaultBranch: {
    type: 'string',
    shortFlag: 'b',
    default: 'main',
    description: 'Repository default branch'
  },
  visibility: {
    type: 'string',
    shortFlag: 'v',
    default: 'private',
    description: 'Repository visibility (Default Private)'
  }
};

// Internal functions

function setupCommand$5(name, description, argv, importMeta) {
  const flags = {
    ..._flags$5.commonFlags,
    ..._flags$5.outputFlags,
    ...repositoryUpdateFlags
  };
  const cli = (0, _meow$5.default)(`
    Usage
      $ ${name} <org slug>

    Options
      ${(0, _formatting$5.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    repoName
  } = cli.flags;
  const [orgSlug = ''] = cli.input;
  let showHelp = cli.flags['help'];
  if (!orgSlug) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$5.bgRed(_yoctocolorsCjs$5.white('Input error'))}: Please provide an organization slug and repository name.`);
  } else if (!repoName) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$5.bgRed(_yoctocolorsCjs$5.white('Input error'))}: Repository name is required.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    name: repoName,
    description: cli.flags['repoDescription'],
    homepage: cli.flags['homepage'],
    default_branch: cli.flags['defaultBranch'],
    visibility: cli.flags['visibility']
  };
}
async function updateRepository(orgSlug, input, spinner, apiKey) {
  const socketSdk = await (0, _sdk$5.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$5.handleApiCall)(socketSdk.updateOrgRepo(orgSlug, input.name, input), 'updating repository');
  if (result.success) {
    spinner.success('Repository updated successfully');
  } else {
    (0, _apiHelpers$5.handleUnsuccessfulApiResponse)('updateOrgRepo', result, spinner);
  }
}

var view$1 = {};

var _interopRequireDefault$5 = require$$0$1.default;
Object.defineProperty(view$1, "__esModule", {
  value: true
});
view$1.view = void 0;
var _yoctocolorsCjs$4 = require$$1$2;
var _chalkTable$1 = require$$2$5;
var _meow$4 = _interopRequireDefault$5(require$$2);
var _yoctoSpinner$4 = require$$3;
var _flags$4 = flags$1;
var _apiHelpers$4 = apiHelpers;
var _errors$5 = sdk.errors;
var _formatting$4 = formatting;
var _sdk$4 = sdk.sdk;
// @ts-ignore

const view = view$1.view = {
  description: 'View repositories in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} view`;
    const input = setupCommand$4(name, view.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$4.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$5.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Fetching repository... \n';
      const spinner = _yoctoSpinner$4({
        text: spinnerText
      }).start();
      await viewRepository(input.orgSlug, input.repositoryName, spinner, apiKey);
    }
  }
};

// Internal functions

function setupCommand$4(name, description, argv, importMeta) {
  const flags = {
    ..._flags$4.commonFlags,
    ..._flags$4.outputFlags
  };
  const cli = (0, _meow$4.default)(`
    Usage
      $ ${name} <org slug>

    Options
      ${(0, _formatting$4.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$4.bgRed(_yoctocolorsCjs$4.white('Input error'))}: Please provide an organization slug and repository name.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = '',
    1: repositoryName = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    repositoryName
  };
}
async function viewRepository(orgSlug, repoName, spinner, apiKey) {
  const socketSdk = await (0, _sdk$4.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$4.handleApiCall)(socketSdk.getOrgRepo(orgSlug, repoName), 'fetching repository');
  if (!result.success) {
    (0, _apiHelpers$4.handleUnsuccessfulApiResponse)('getOrgRepo', result, spinner);
    return;
  }
  const options = {
    columns: [{
      field: 'id',
      name: _yoctocolorsCjs$4.magenta('ID')
    }, {
      field: 'name',
      name: _yoctocolorsCjs$4.magenta('Name')
    }, {
      field: 'visibility',
      name: _yoctocolorsCjs$4.magenta('Visibility')
    }, {
      field: 'default_branch',
      name: _yoctocolorsCjs$4.magenta('Default branch')
    }, {
      field: 'homepage',
      name: _yoctocolorsCjs$4.magenta('Homepage')
    }, {
      field: 'archived',
      name: _yoctocolorsCjs$4.magenta('Archived')
    }, {
      field: 'created_at',
      name: _yoctocolorsCjs$4.magenta('Created at')
    }]
  };
  spinner.stop(_chalkTable$1(options, [result.data]));
}

Object.defineProperty(repos, "__esModule", {
  value: true
});
repos.repo = void 0;
var _create = create$1;
var _delete = _delete$1;
var _list = list$1;
var _update = update$1;
var _view = view$1;
var _meowWithSubcommands$2 = meowWithSubcommands$1;
const description$1 = 'Repositories related commands';
repos.repo = {
  description: description$1,
  run: async (argv, importMeta, {
    parentName
  }) => {
    await (0, _meowWithSubcommands$2.meowWithSubcommands)({
      create: _create.create,
      view: _view.view,
      list: _list.list,
      del: _delete.del,
      update: _update.update
    }, {
      argv,
      description: description$1,
      importMeta,
      name: `${parentName} repo`
    });
  }
};

var dependencies$1 = {};

var _interopRequireDefault$4 = require$$0$1.default;
Object.defineProperty(dependencies$1, "__esModule", {
  value: true
});
dependencies$1.dependencies = void 0;
var _yoctocolorsCjs$3 = require$$1$2;
var _chalkTable = require$$2$5;
var _meow$3 = _interopRequireDefault$4(require$$2);
var _yoctoSpinner$3 = require$$3;
var _flags$3 = flags$1;
var _apiHelpers$3 = apiHelpers;
var _errors$4 = sdk.errors;
var _formatting$3 = formatting;
var _sdk$3 = sdk.sdk;
// @ts-ignore

const dependencies = dependencies$1.dependencies = {
  description: 'Search for any dependency that is being used in your organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = parentName + ' dependencies';
    const input = setupCommand$3(name, dependencies.description, argv, importMeta);
    if (input) {
      await searchDeps(input);
    }
  }
};
const dependenciesFlags = {
  limit: {
    type: 'number',
    shortFlag: 'l',
    default: 50,
    description: 'Maximum number of dependencies returned'
  },
  offset: {
    type: 'number',
    shortFlag: 'o',
    default: 0,
    description: 'Page number'
  }
};

// Internal functions

function setupCommand$3(name, description, argv, importMeta) {
  const flags = {
    ..._flags$3.commonFlags,
    ...dependenciesFlags,
    ..._flags$3.outputFlags
  };
  const cli = (0, _meow$3.default)(`
    Usage
      $ ${name}

    Options
      ${(0, _formatting$3.printFlagList)(flags, 6)}

    Examples
      $ ${name}
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    json: outputJson,
    limit,
    markdown: outputMarkdown,
    offset
  } = cli.flags;
  return {
    outputJson,
    outputMarkdown,
    limit,
    offset
  };
}
async function searchDeps({
  limit,
  offset,
  outputJson
}) {
  const apiKey = (0, _sdk$3.getDefaultKey)();
  if (!apiKey) {
    throw new _errors$4.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  const spinner = _yoctoSpinner$3({
    text: 'Searching dependencies...'
  }).start();
  const socketSdk = await (0, _sdk$3.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$3.handleApiCall)(socketSdk.searchDependencies({
    limit,
    offset
  }), 'Searching dependencies');
  if (!result.success) {
    (0, _apiHelpers$3.handleUnsuccessfulApiResponse)('searchDependencies', result, spinner);
    return;
  }
  spinner.stop('Organization dependencies:');
  if (outputJson) {
    console.log(result.data);
    return;
  }
  const options = {
    columns: [{
      field: 'namespace',
      name: _yoctocolorsCjs$3.cyan('Namespace')
    }, {
      field: 'name',
      name: _yoctocolorsCjs$3.cyan('Name')
    }, {
      field: 'version',
      name: _yoctocolorsCjs$3.cyan('Version')
    }, {
      field: 'repository',
      name: _yoctocolorsCjs$3.cyan('Repository')
    }, {
      field: 'branch',
      name: _yoctocolorsCjs$3.cyan('Branch')
    }, {
      field: 'type',
      name: _yoctocolorsCjs$3.cyan('Type')
    }, {
      field: 'direct',
      name: _yoctocolorsCjs$3.cyan('Direct')
    }]
  };
  console.log(_chalkTable(options, result.data.rows));
}

var analytics$1 = {};

var _interopRequireDefault$3 = require$$0$1.default;
Object.defineProperty(analytics$1, "__esModule", {
  value: true
});
analytics$1.analytics = void 0;
var _promises = require$$1$4;
var _screen$1 = require$$2$6;
var _bar = require$$3$5;
var _grid = require$$4$4;
var _line = require$$5$4;
var _meow$2 = _interopRequireDefault$3(require$$2);
var _yoctocolorsCjs$2 = require$$1$2;
var _yoctoSpinner$2 = require$$3;
var _flags$2 = flags$1;
var _apiHelpers$2 = apiHelpers;
var _errors$3 = sdk.errors;
var _formatting$2 = formatting;
var _sdk$2 = sdk.sdk;
// @ts-ignore

// @ts-ignore

// @ts-ignore

// @ts-ignore

const analytics = analytics$1.analytics = {
  description: `Look up analytics data \n
  Default parameters are set to show the organization-level analytics over the last 7 days.`,
  async run(argv, importMeta, {
    parentName
  }) {
    const name = parentName + ' analytics';
    const input = setupCommand$2(name, analytics.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$2.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$3.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinner = _yoctoSpinner$2({
        text: 'Fetching analytics data'
      }).start();
      if (input.scope === 'org') {
        await fetchOrgAnalyticsData(input.time, spinner, apiKey, input.outputJson, input.file);
      } else {
        if (input.repo) {
          await fetchRepoAnalyticsData(input.repo, input.time, spinner, apiKey, input.outputJson, input.file);
        }
      }
    }
  }
};
const analyticsFlags = {
  scope: {
    type: 'string',
    shortFlag: 's',
    default: 'org',
    description: "Scope of the analytics data - either 'org' or 'repo'"
  },
  time: {
    type: 'number',
    shortFlag: 't',
    default: 7,
    description: 'Time filter - either 7, 30 or 90'
  },
  repo: {
    type: 'string',
    shortFlag: 'r',
    default: '',
    description: 'Name of the repository'
  },
  file: {
    type: 'string',
    shortFlag: 'f',
    default: '',
    description: 'Path to a local file to save the output'
  }
};

// Internal functions

function setupCommand$2(name, description, argv, importMeta) {
  const flags = {
    ..._flags$2.commonFlags,
    ..._flags$2.outputFlags,
    ...analyticsFlags
  };
  const cli = (0, _meow$2.default)(`
    Usage
      $ ${name} --scope=<scope> --time=<time filter>

    Options
      ${(0, _formatting$2.printFlagList)(flags, 6)}

    Examples
      $ ${name} --scope=org --time=7
      $ ${name} --scope=org --time=30
      $ ${name} --scope=repo --repo=test-repo --time=30
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    repo,
    scope,
    time
  } = cli.flags;
  if (scope !== 'org' && scope !== 'repo') {
    throw new _errors$3.InputError("The scope must either be 'org' or 'repo'");
  }
  if (time !== 7 && time !== 30 && time !== 90) {
    throw new _errors$3.InputError('The time filter must either be 7, 30 or 90');
  }
  let showHelp = cli.flags['help'];
  if (scope === 'repo' && !repo) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$2.bgRed(_yoctocolorsCjs$2.white('Input error'))}: Please provide a repository name when using the repository scope.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    scope,
    time,
    repo,
    outputJson: cli.flags['json'],
    file: cli.flags['file']
  };
}
const METRICS = ['total_critical_alerts', 'total_high_alerts', 'total_medium_alerts', 'total_low_alerts', 'total_critical_added', 'total_medium_added', 'total_low_added', 'total_high_added', 'total_critical_prevented', 'total_high_prevented', 'total_medium_prevented', 'total_low_prevented'];
async function fetchOrgAnalyticsData(time, spinner, apiKey, outputJson, filePath) {
  const socketSdk = await (0, _sdk$2.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$2.handleApiCall)(socketSdk.getOrgAnalytics(time.toString()), 'fetching analytics data');
  if (result.success === false) {
    return (0, _apiHelpers$2.handleUnsuccessfulApiResponse)('getOrgAnalytics', result, spinner);
  }
  spinner.stop();
  if (!result.data.length) {
    return console.log('No analytics data is available for this organization yet.');
  }
  const data = formatData(result.data, 'org');
  if (outputJson && !filePath) {
    return console.log(result.data);
  }
  if (filePath) {
    try {
      await _promises.writeFile(filePath, JSON.stringify(result.data), 'utf8');
      console.log(`Data successfully written to ${filePath}`);
    } catch (e) {
      console.error(e);
    }
    return;
  }
  return displayAnalyticsScreen(data);
}
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const formatDate = date => {
  return `${months[new Date(date).getMonth()]} ${new Date(date).getDate()}`;
};
const formatData = (data, scope) => {
  let formattedData, sortedTopFiveAlerts;
  if (scope === 'org') {
    const topFiveAlerts = data.map(d => d['top_five_alert_types']);
    const totalTopAlerts = topFiveAlerts.reduce((acc, current) => {
      const alertTypes = Object.keys(current);
      alertTypes.map(type => {
        if (!acc[type]) {
          acc[type] = current[type];
        } else {
          acc[type] += current[type];
        }
        return acc;
      });
      return acc;
    }, {});
    sortedTopFiveAlerts = Object.entries(totalTopAlerts).sort(({
      1: a
    }, {
      1: b
    }) => b - a).slice(0, 5).reduce((r, {
      0: k,
      1: v
    }) => {
      r[k] = v;
      return r;
    }, {});
    const formatData = label => {
      return data.reduce((acc, current) => {
        const date = formatDate(current['created_at']);
        if (!acc[date]) {
          acc[date] = current[label];
        } else {
          acc[date] += current[label];
        }
        return acc;
      }, {});
    };
    formattedData = METRICS.reduce((acc, current) => {
      acc[current] = formatData(current);
      return acc;
    }, {});
  } else if (scope === 'repo') {
    const topAlerts = data.reduce((acc, current) => {
      const alertTypes = Object.keys(current['top_five_alert_types']);
      alertTypes.map(type => {
        if (!acc[type]) {
          acc[type] = current['top_five_alert_types'][type];
        } else {
          if (current['top_five_alert_types'][type] > (acc[type] || 0)) {
            acc[type] = current['top_five_alert_types'][type];
          }
        }
        return acc;
      });
      return acc;
    }, {});
    sortedTopFiveAlerts = Object.entries(topAlerts).sort(({
      1: a
    }, {
      1: b
    }) => b - a).slice(0, 5).reduce((r, {
      0: k,
      1: v
    }) => {
      r[k] = v;
      return r;
    }, {});
    formattedData = data.reduce((acc, current) => {
      METRICS.forEach(m => {
        if (!acc[m]) {
          acc[m] = {};
        }
        acc[m][formatDate(current['created_at'])] = current[m];
        return acc;
      });
      return acc;
    }, {});
  }
  return {
    ...formattedData,
    top_five_alert_types: sortedTopFiveAlerts
  };
};
async function fetchRepoAnalyticsData(repo, time, spinner, apiKey, outputJson, filePath) {
  const socketSdk = await (0, _sdk$2.setupSdk)(apiKey);
  const result = await (0, _apiHelpers$2.handleApiCall)(socketSdk.getRepoAnalytics(repo, time.toString()), 'fetching analytics data');
  if (result.success === false) {
    return (0, _apiHelpers$2.handleUnsuccessfulApiResponse)('getRepoAnalytics', result, spinner);
  }
  spinner.stop();
  if (!result.data.length) {
    return console.log('No analytics data is available for this organization yet.');
  }
  const data = formatData(result.data, 'repo');
  if (outputJson && !filePath) {
    return console.log(result.data);
  }
  if (filePath) {
    try {
      await _promises.writeFile(filePath, JSON.stringify(result.data), 'utf8');
      console.log(`Data successfully written to ${filePath}`);
    } catch (e) {
      console.error(e);
    }
    return;
  }
  return displayAnalyticsScreen(data);
}
const displayAnalyticsScreen = data => {
  const screen = new _screen$1();
  const grid = new _grid({
    rows: 5,
    cols: 4,
    screen
  });
  renderLineCharts(grid, screen, 'Total critical alerts', [0, 0, 1, 2], data['total_critical_alerts']);
  renderLineCharts(grid, screen, 'Total high alerts', [0, 2, 1, 2], data['total_high_alerts']);
  renderLineCharts(grid, screen, 'Total critical alerts added to the main branch', [1, 0, 1, 2], data['total_critical_added']);
  renderLineCharts(grid, screen, 'Total high alerts added to the main branch', [1, 2, 1, 2], data['total_high_added']);
  renderLineCharts(grid, screen, 'Total critical alerts prevented from the main branch', [2, 0, 1, 2], data['total_critical_prevented']);
  renderLineCharts(grid, screen, 'Total high alerts prevented from the main branch', [2, 2, 1, 2], data['total_high_prevented']);
  renderLineCharts(grid, screen, 'Total medium alerts prevented from the main branch', [3, 0, 1, 2], data['total_medium_prevented']);
  renderLineCharts(grid, screen, 'Total low alerts prevented from the main branch', [3, 2, 1, 2], data['total_low_prevented']);
  const bar = grid.set(4, 0, 1, 2, _bar, {
    label: 'Top 5 alert types',
    barWidth: 10,
    barSpacing: 17,
    xOffset: 0,
    maxHeight: 9,
    barBgColor: 'magenta'
  });
  screen.append(bar); //must append before setting data

  bar.setData({
    titles: Object.keys(data.top_five_alert_types),
    data: Object.values(data.top_five_alert_types)
  });
  screen.render();
  screen.key(['escape', 'q', 'C-c'], () => process.exit(0));
};
const renderLineCharts = (grid, screen, title, coords, data) => {
  const line = grid.set(...coords, _line, {
    style: {
      line: 'cyan',
      text: 'cyan',
      baseline: 'black'
    },
    xLabelPadding: 0,
    xPadding: 0,
    xOffset: 0,
    wholeNumbersOnly: true,
    legend: {
      width: 1
    },
    label: title
  });
  screen.append(line);
  const lineData = {
    x: Object.keys(data),
    y: Object.values(data)
  };
  line.setData([lineData]);
};

var diffScan = {};

var get$1 = {};

var _interopRequireDefault$2 = require$$0$1.default;
Object.defineProperty(get$1, "__esModule", {
  value: true
});
get$1.get = void 0;
var _nodeFs = require$$0;
var _nodeUtil = require$$2$7;
var _yoctocolorsCjs$1 = require$$1$2;
var _meow$1 = _interopRequireDefault$2(require$$2);
var _yoctoSpinner$1 = require$$3;
var _flags$1 = flags$1;
var _apiHelpers$1 = apiHelpers;
var _errors$2 = sdk.errors;
var _formatting$1 = formatting;
var _sdk$1 = sdk.sdk;
const get = get$1.get = {
  description: 'Get a diff scan for an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} get`;
    const input = setupCommand$1(name, get.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk$1.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$2.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Getting diff scan... \n';
      const spinner = _yoctoSpinner$1({
        text: spinnerText
      }).start();
      await getDiffScan(input, spinner, apiKey);
    }
  }
};
const getDiffScanFlags = {
  before: {
    type: 'string',
    shortFlag: 'b',
    default: '',
    description: 'The full scan ID of the base scan'
  },
  after: {
    type: 'string',
    shortFlag: 'a',
    default: '',
    description: 'The full scan ID of the head scan'
  },
  preview: {
    type: 'boolean',
    shortFlag: 'p',
    default: true,
    description: 'A boolean flag to persist or not the diff scan result'
  },
  file: {
    type: 'string',
    shortFlag: 'f',
    default: '',
    description: 'Path to a local file where the output should be saved'
  }
};

// Internal functions

function setupCommand$1(name, description, argv, importMeta) {
  const flags = {
    ..._flags$1.commonFlags,
    ...getDiffScanFlags,
    ..._flags$1.outputFlags
  };
  const cli = (0, _meow$1.default)(`
    Usage
      $ ${name} <org slug> --before=<before> --after=<after>

    Options
      ${(0, _formatting$1.printFlagList)(flags, 6)}

    Examples
      $ ${name} FakeCorp --before=aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 --after=aaa1aa1a-aaaa-1111-1a1a-1111111a11a1
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    after,
    before
  } = cli.flags;
  let showHelp = cli.flags['help'];
  if (!before || !after) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$1.bgRed(_yoctocolorsCjs$1.white('Input error'))}: Please specify a before and after full scan ID. To get full scans IDs, you can run the command "socket scan list <your org slug>".`);
  } else if (cli.input.length < 1) {
    showHelp = true;
    console.error(`${_yoctocolorsCjs$1.bgRed(_yoctocolorsCjs$1.white('Input error'))}: Please provide an organization slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const [orgSlug = ''] = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    before,
    after,
    preview: cli.flags['preview'],
    orgSlug,
    file: cli.flags['file']
  };
}
async function getDiffScan({
  after,
  before,
  file,
  orgSlug,
  outputJson
}, spinner, apiKey) {
  const response = await (0, _apiHelpers$1.queryAPI)(`${orgSlug}/full-scans/diff?before=${before}&after=${after}&preview`, apiKey);
  const data = await response.json();
  if (!response.ok) {
    const err = await (0, _apiHelpers$1.handleAPIError)(response.status);
    spinner.error(`${_yoctocolorsCjs$1.bgRed(_yoctocolorsCjs$1.white(response.statusText))}: ${err}`);
    return;
  }
  spinner.stop();
  if (file && !outputJson) {
    _nodeFs.writeFile(file, JSON.stringify(data), err => {
      err ? console.error(err) : console.log(`Data successfully written to ${file}`);
    });
    return;
  }
  if (outputJson) {
    console.log(`\n Diff scan result: \n`);
    console.log(_nodeUtil.inspect(data, {
      showHidden: false,
      depth: null,
      colors: true
    }));
    console.log(`\n View this diff scan in the Socket dashboard: ${_yoctocolorsCjs$1.cyan(data?.['diff_report_url'])}`);
    return;
  }
  console.log('Diff scan result:');
  console.log(data);
  console.log(`\n 📝 To display the detailed report in the terminal, use the --json flag \n`);
  console.log(`\n View this diff scan in the Socket dashboard: ${_yoctocolorsCjs$1.cyan(data?.['diff_report_url'])}`);
}

Object.defineProperty(diffScan, "__esModule", {
  value: true
});
diffScan.diffScan = void 0;
var _get = get$1;
var _meowWithSubcommands$1 = meowWithSubcommands$1;
const description = 'Diff scans related commands';
diffScan.diffScan = {
  description,
  run: async (argv, importMeta, {
    parentName
  }) => {
    await (0, _meowWithSubcommands$1.meowWithSubcommands)({
      get: _get.get
    }, {
      argv,
      description,
      importMeta,
      name: parentName + ' diff-scan'
    });
  }
};

var threatFeed$1 = {};

var _interopRequireDefault$1 = require$$0$1.default;
Object.defineProperty(threatFeed$1, "__esModule", {
  value: true
});
threatFeed$1.threatFeed = void 0;
var _screen = require$$2$6;
var _table = require$$2$8;
var _meow = _interopRequireDefault$1(require$$2);
var _yoctoSpinner = require$$3;
var _flags = flags$1;
var _apiHelpers = apiHelpers;
var _errors$1 = sdk.errors;
var _formatting = formatting;
var _sdk = sdk.sdk;
// @ts-ignore

// @ts-ignore

const threatFeed = threatFeed$1.threatFeed = {
  description: 'Look up the threat feed',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} threat-feed`;
    const input = setupCommand(name, threatFeed.description, argv, importMeta);
    if (input) {
      const apiKey = (0, _sdk.getDefaultKey)();
      if (!apiKey) {
        throw new _errors$1.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinner = _yoctoSpinner({
        text: 'Looking up the threat feed'
      }).start();
      await fetchThreatFeed(input, spinner, apiKey);
    }
  }
};
const threatFeedFlags = {
  perPage: {
    type: 'number',
    shortFlag: 'pp',
    default: 30,
    description: 'Number of items per page'
  },
  page: {
    type: 'string',
    shortFlag: 'p',
    default: '1',
    description: 'Page token'
  },
  direction: {
    type: 'string',
    shortFlag: 'd',
    default: 'desc',
    description: 'Order asc or desc by the createdAt attribute.'
  },
  filter: {
    type: 'string',
    shortFlag: 'f',
    default: 'mal',
    description: 'Filter what type of threats to return'
  }
};

// Internal functions

function setupCommand(name, description, argv, importMeta) {
  const flags = {
    ..._flags.commonFlags,
    ..._flags.outputFlags,
    ...threatFeedFlags
  };
  const cli = (0, _meow.default)(`
    Usage
      $ ${name}

    Options
      ${(0, _formatting.printFlagList)(flags, 6)}

    Examples
      $ ${name}
      $ ${name} --perPage=5 --page=2 --direction=asc --filter=joke
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    direction,
    filter,
    json: outputJson,
    markdown: outputMarkdown,
    page,
    perPage: per_page
  } = cli.flags;
  return {
    outputJson,
    outputMarkdown,
    per_page,
    page,
    direction,
    filter
  };
}
async function fetchThreatFeed({
  direction,
  filter,
  outputJson,
  page,
  per_page
}, spinner, apiKey) {
  const formattedQueryParams = formatQueryParams({
    per_page,
    page,
    direction,
    filter
  }).join('&');
  const response = await (0, _apiHelpers.queryAPI)(`threat-feed?${formattedQueryParams}`, apiKey);
  const data = await response.json();
  spinner.stop();
  if (outputJson) {
    console.log(data);
    return;
  }
  const screen = new _screen();
  const table = new _table({
    keys: 'true',
    fg: 'white',
    selectedFg: 'white',
    selectedBg: 'magenta',
    interactive: 'true',
    label: 'Threat feed',
    width: '100%',
    height: '100%',
    border: {
      type: 'line',
      fg: 'cyan'
    },
    columnSpacing: 3,
    //in chars
    columnWidth: [9, 30, 10, 17, 13, 100] /*in chars*/
  });

  // allow control the table with the keyboard
  table.focus();
  screen.append(table);
  const formattedOutput = formatResults(data.results);
  table.setData({
    headers: ['Ecosystem', 'Name', 'Version', 'Threat type', 'Detected at', 'Details'],
    data: formattedOutput
  });
  screen.render();
  screen.key(['escape', 'q', 'C-c'], () => process.exit(0));
}
const formatResults = data => {
  return data.map(d => {
    const ecosystem = d.purl.split('pkg:')[1].split('/')[0];
    const name = d.purl.split('/')[1].split('@')[0];
    const version = d.purl.split('@')[1];
    const timeStart = new Date(d.createdAt).getMilliseconds();
    const timeEnd = Date.now();
    const diff = getHourDiff(timeStart, timeEnd);
    const hourDiff = diff > 0 ? `${diff} hours ago` : `${getMinDiff(timeStart, timeEnd)} minutes ago`;
    return [ecosystem, decodeURIComponent(name), version, d.threatType, hourDiff, d.locationHtmlUrl];
  });
};
const formatQueryParams = params => Object.entries(params).map(entry => `${entry[0]}=${entry[1]}`);
const getHourDiff = (start, end) => Math.floor((end - start) / 3600000);
const getMinDiff = (start, end) => Math.floor((end - start) / 60000);

(function (exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _cdxgen = cdxgen;
	Object.keys(_cdxgen).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _cdxgen[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _cdxgen[key];
	    }
	  });
	});
	var _info = info$1;
	Object.keys(_info).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _info[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _info[key];
	    }
	  });
	});
	var _login = login;
	Object.keys(_login).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _login[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _login[key];
	    }
	  });
	});
	var _logout = logout;
	Object.keys(_logout).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _logout[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _logout[key];
	    }
	  });
	});
	var _npm = npm;
	Object.keys(_npm).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _npm[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _npm[key];
	    }
	  });
	});
	var _npx = npx;
	Object.keys(_npx).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _npx[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _npx[key];
	    }
	  });
	});
	var _optimize = optimize$1;
	Object.keys(_optimize).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _optimize[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _optimize[key];
	    }
	  });
	});
	var _organization = organization;
	Object.keys(_organization).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _organization[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _organization[key];
	    }
	  });
	});
	var _rawNpm = rawNpm$1;
	Object.keys(_rawNpm).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _rawNpm[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _rawNpm[key];
	    }
	  });
	});
	var _rawNpx = rawNpx$1;
	Object.keys(_rawNpx).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _rawNpx[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _rawNpx[key];
	    }
	  });
	});
	var _report = report;
	Object.keys(_report).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _report[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _report[key];
	    }
	  });
	});
	var _wrapper = wrapper$1;
	Object.keys(_wrapper).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _wrapper[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _wrapper[key];
	    }
	  });
	});
	var _scan = scan;
	Object.keys(_scan).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _scan[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _scan[key];
	    }
	  });
	});
	var _auditLog = auditLog$1;
	Object.keys(_auditLog).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _auditLog[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _auditLog[key];
	    }
	  });
	});
	var _repos = repos;
	Object.keys(_repos).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _repos[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _repos[key];
	    }
	  });
	});
	var _dependencies = dependencies$1;
	Object.keys(_dependencies).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _dependencies[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _dependencies[key];
	    }
	  });
	});
	var _analytics = analytics$1;
	Object.keys(_analytics).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _analytics[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _analytics[key];
	    }
	  });
	});
	var _diffScan = diffScan;
	Object.keys(_diffScan).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _diffScan[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _diffScan[key];
	    }
	  });
	});
	var _threatFeed = threatFeed$1;
	Object.keys(_threatFeed).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (key in exports && exports[key] === _threatFeed[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _threatFeed[key];
	    }
	  });
	}); 
} (commands));

var _interopRequireWildcard = require$$0$2.default;
var _interopRequireDefault = require$$0$1.default;
var _nodeUrl = require$$2$9;
var _yoctocolorsCjs = require$$1$2;
var _ponyCause = require$$4$1;
var _tinyUpdater = _interopRequireDefault(require$$5$5);
var cliCommands = _interopRequireWildcard(commands, true);
var _constants = constants.constants;
var _colorOrMarkdown = sdk.colorOrMarkdown;
var _errors = sdk.errors;
var _meowWithSubcommands = meowWithSubcommands$1;
const formattedCliCommands = Object.fromEntries(Object.entries(cliCommands).map(entry => {
  const key = entry[0];
  entry[0] = camelToHyphen(key);
  return entry;
}));
function camelToHyphen(str) {
  return str.replace(/[A-Z]+/g, '-$&').toLowerCase();
}

// TODO: Add autocompletion using https://socket.dev/npm/package/omelette
void (async () => {
  const rootPkgJson = require(_constants.rootPkgJsonPath);
  await (0, _tinyUpdater.default)({
    name: rootPkgJson.name,
    version: rootPkgJson.version,
    ttl: 86_400_000 /* 24 hours in milliseconds */
  });
  try {
    await (0, _meowWithSubcommands.meowWithSubcommands)(formattedCliCommands, {
      aliases: {
        ci: {
          description: 'Alias for "report create --view --strict"',
          argv: ['report', 'create', '--view', '--strict']
        }
      },
      argv: process.argv.slice(2),
      name: 'socket',
      importMeta: {
        url: `${(0, _nodeUrl.pathToFileURL)(__filename)}`
      }
    });
  } catch (err) {
    let errorBody;
    let errorTitle;
    let errorMessage = '';
    if (err instanceof _errors.AuthError) {
      errorTitle = 'Authentication error';
      errorMessage = err.message;
    } else if (err instanceof _errors.InputError) {
      errorTitle = 'Invalid input';
      errorMessage = err.message;
      errorBody = err.body;
    } else if (err instanceof Error) {
      errorTitle = 'Unexpected error';
      errorMessage = (0, _ponyCause.messageWithCauses)(err);
      errorBody = (0, _ponyCause.stackWithCauses)(err);
    } else {
      errorTitle = 'Unexpected error with no details';
    }
    console.error(`${_colorOrMarkdown.logSymbols.error} ${_yoctocolorsCjs.bgRed(_yoctocolorsCjs.white(errorTitle + ':'))} ${errorMessage}`);
    if (errorBody) {
      console.error(`\n${errorBody}`);
    }
    process.exit(1);
  }
})();

(function (exports) {

	var _interopRequireWildcard = require$$0$2.default;
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _exportNames = {};
	Object.defineProperty(exports, "default", {
	  enumerable: true,
	  get: function () {
	    return _cli.default;
	  }
	});
	var _cli = _interopRequireWildcard(cli$1, true);
	Object.keys(_cli).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
	  if (key in exports && exports[key] === _cli[key]) return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function () {
	      return _cli[key];
	    }
	  });
	}); 
} (cli$2));

var cli = /*@__PURE__*/constants.getDefaultExportFromCjs(cli$2);

module.exports = cli;
