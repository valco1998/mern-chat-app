'use strict';

var require$$1$1 = require('node:fs/promises');
var require$$1 = require('node:path');
var require$$2 = require('ignore');
var require$$3 = require('micromatch');
var require$$8 = require('tinyglobby');

var pathResolve = {};

var ignoreByDefault = {};

Object.defineProperty(ignoreByDefault, "__esModule", {
  value: true
});
ignoreByDefault.directoryPatterns = directoryPatterns;
const ignoredDirs = [
// Taken from ignore-by-default:
// https://github.com/novemberborn/ignore-by-default/blob/v2.1.0/index.js
'.git',
// Git repository files, see <https://git-scm.com/>
'.log',
// Log files emitted by tools such as `tsserver`, see <https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29>
'.nyc_output',
// Temporary directory where nyc stores coverage data, see <https://github.com/bcoe/nyc>
'.sass-cache',
// Cache folder for node-sass, see <https://github.com/sass/node-sass>
'.yarn',
// Where node modules are installed when using Yarn, see <https://yarnpkg.com/>
'bower_components',
// Where Bower packages are installed, see <http://bower.io/>
'coverage',
// Standard output directory for code coverage reports, see <https://github.com/gotwarlost/istanbul>
'node_modules',
// Where Node modules are installed, see <https://nodejs.org/>
// Taken from globby:
// https://github.com/sindresorhus/globby/blob/v14.0.2/ignore.js#L11-L16
'flow-typed'];
const ignoredDirPatterns = ignoredDirs.map(i => `**/${i}`);
function directoryPatterns() {
  return [...ignoredDirPatterns];
}

Object.defineProperty(pathResolve, "__esModule", {
  value: true
});
pathResolve.findRoot = findRoot;
pathResolve.getPackageFiles = getPackageFiles;
pathResolve.getPackageFilesFullScans = getPackageFilesFullScans;
var _promises = require$$1$1;
var _nodePath = require$$1;
var _ignore = require$$2;
var _micromatch = require$$3;
var _tinyglobby = require$$8;
var _ignoreByDefault = ignoreByDefault;
async function filterGlobResultToSupportedFiles(entries, supportedFiles) {
  const patterns = ['golang', 'npm', 'pypi'].reduce((r, n) => {
    const supported = supportedFiles[n];
    r.push(...(supported ? Object.values(supported).map(p => `**/${p.pattern}`) : []));
    return r;
  }, []);
  return entries.filter(p => _micromatch.some(p, patterns));
}
async function globWithGitIgnore(patterns, options) {
  const {
    cwd = process.cwd(),
    socketConfig,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const projectIgnorePaths = socketConfig?.projectIgnorePaths;
  const ignoreFiles = await (0, _tinyglobby.glob)(['**/.gitignore'], {
    absolute: true,
    cwd,
    expandDirectories: true
  });
  const ignores = [...(0, _ignoreByDefault.directoryPatterns)(), ...(Array.isArray(projectIgnorePaths) ? ignoreFileLinesToGlobPatterns(projectIgnorePaths, _nodePath.join(cwd, '.gitignore'), cwd) : []), ...(await Promise.all(ignoreFiles.map(async filepath => ignoreFileToGlobPatterns(await _promises.readFile(filepath, 'utf8'), filepath, cwd)))).flat()];
  const hasNegatedPattern = ignores.some(p => p.charCodeAt(0) === 33 /*'!'*/);
  const globOptions = {
    absolute: true,
    cwd,
    expandDirectories: false,
    ignore: hasNegatedPattern ? [] : ignores,
    ...additionalOptions
  };
  const result = await (0, _tinyglobby.glob)(patterns, globOptions);
  if (!hasNegatedPattern) {
    return result;
  }
  const {
    absolute
  } = globOptions;
  const filtered = _ignore().add(ignores).filter(absolute ? result.map(p => _nodePath.relative(cwd, p)) : result);
  return absolute ? filtered.map(p => _nodePath.resolve(cwd, p)) : filtered;
}
function ignoreFileLinesToGlobPatterns(lines, filepath, cwd) {
  const base = _nodePath.relative(cwd, _nodePath.dirname(filepath)).replace(/\\/g, '/');
  const patterns = [];
  for (let i = 0, {
      length
    } = lines; i < length; i += 1) {
    const pattern = lines[i].trim();
    if (pattern.length > 0 && pattern.charCodeAt(0) !== 35 /*'#'*/) {
      patterns.push(ignorePatternToMinimatch(pattern.length && pattern.charCodeAt(0) === 33 /*'!'*/ ? `!${_nodePath.posix.join(base, pattern.slice(1))}` : _nodePath.posix.join(base, pattern)));
    }
  }
  return patterns;
}
function ignoreFileToGlobPatterns(content, filepath, cwd) {
  return ignoreFileLinesToGlobPatterns(content.split(/\r?\n/), filepath, cwd);
}

// Based on `@eslint/compat` convertIgnorePatternToMinimatch.
// Apache v2.0 licensed
// Copyright Nicholas C. Zakas
// https://github.com/eslint/rewrite/blob/compat-v1.2.1/packages/compat/src/ignore-file.js#L28
function ignorePatternToMinimatch(pattern) {
  const isNegated = pattern.startsWith('!');
  const negatedPrefix = isNegated ? '!' : '';
  const patternToTest = (isNegated ? pattern.slice(1) : pattern).trimEnd();
  // Special cases.
  if (patternToTest === '' || patternToTest === '**' || patternToTest === '/**' || patternToTest === '**') {
    return `${negatedPrefix}${patternToTest}`;
  }
  const firstIndexOfSlash = patternToTest.indexOf('/');
  const matchEverywherePrefix = firstIndexOfSlash === -1 || firstIndexOfSlash === patternToTest.length - 1 ? '**/' : '';
  const patternWithoutLeadingSlash = firstIndexOfSlash === 0 ? patternToTest.slice(1) : patternToTest;
  // Escape `{` and `(` because in gitignore patterns they are just
  // literal characters without any specific syntactic meaning,
  // while in minimatch patterns they can form brace expansion or extglob syntax.
  //
  // For example, gitignore pattern `src/{a,b}.js` ignores file `src/{a,b}.js`.
  // But, the same minimatch pattern `src/{a,b}.js` ignores files `src/a.js` and `src/b.js`.
  // Minimatch pattern `src/\{a,b}.js` is equivalent to gitignore pattern `src/{a,b}.js`.
  const escapedPatternWithoutLeadingSlash = patternWithoutLeadingSlash.replaceAll(/(?=((?:\\.|[^{(])*))\1([{(])/guy, '$1\\$2');
  const matchInsideSuffix = patternToTest.endsWith('/**') ? '/*' : '';
  return `${negatedPrefix}${matchEverywherePrefix}${escapedPatternWithoutLeadingSlash}${matchInsideSuffix}`;
}
function pathsToPatterns(paths) {
  return paths.map(p => p === '.' ? '**/*' : p);
}
function findRoot(filepath) {
  let curPath = filepath;
  while (true) {
    if (_nodePath.basename(curPath) === 'npm') {
      return curPath;
    }
    const parent = _nodePath.dirname(curPath);
    if (parent === curPath) {
      return undefined;
    }
    curPath = parent;
  }
}
async function getPackageFiles(cwd, inputPaths, config, supportedFiles, debugLog = () => {}) {
  debugLog(`Globbed resolving ${inputPaths.length} paths:`, inputPaths);

  // TODO: Does not support `~/` paths
  const entries = await globWithGitIgnore(pathsToPatterns(inputPaths), {
    cwd,
    socketConfig: config
  });
  debugLog(`Globbed resolved ${inputPaths.length} paths to ${entries.length} paths:`, entries);
  const packageFiles = await filterGlobResultToSupportedFiles(entries, supportedFiles);
  debugLog(`Mapped ${entries.length} entries to ${packageFiles.length} files:`, packageFiles);
  return packageFiles;
}
async function getPackageFilesFullScans(cwd, inputPaths, supportedFiles, debugLog = () => {}) {
  debugLog(`Globbed resolving ${inputPaths.length} paths:`, inputPaths);

  // TODO: Does not support `~/` paths
  const entries = await globWithGitIgnore(pathsToPatterns(inputPaths), {
    cwd
  });
  debugLog(`Globbed resolved ${inputPaths.length} paths to ${entries.length} paths:`, entries);
  const packageFiles = await filterGlobResultToSupportedFiles(entries, supportedFiles);
  debugLog(`Mapped ${entries.length} entries to ${packageFiles.length} files:`, packageFiles);
  return packageFiles;
}

exports.pathResolve = pathResolve;
