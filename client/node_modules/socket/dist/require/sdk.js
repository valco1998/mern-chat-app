'use strict';

var vendor = require('./vendor.js');
var require$$1 = require('yoctocolors-cjs');
var require$$1$3 = require('@inquirer/prompts');
var require$$2 = require('hpagent');
var require$$4 = require('@socketsecurity/sdk');
var constants = require('./constants.js');
var require$$0 = require('node:fs');
var require$$1$1 = require('node:os');
var require$$1$2 = require('node:path');
var require$$3 = require('@socketregistry/yocto-spinner');

var errors = {};

Object.defineProperty(errors, "__esModule", {
  value: true
});
errors.InputError = errors.AuthError = void 0;
class AuthError extends Error {}
errors.AuthError = AuthError;
class InputError extends Error {
  constructor(message, body) {
    super(message);
    this.body = body;
  }
}
errors.InputError = InputError;

var colorOrMarkdown = {};

var _interopRequireDefault$1 = vendor.interopRequireDefault.default;
Object.defineProperty(colorOrMarkdown, "__esModule", {
  value: true
});
colorOrMarkdown.logSymbols = colorOrMarkdown.ColorOrMarkdown = void 0;
var _yoctocolorsCjs = require$$1;
var _isUnicodeSupported = _interopRequireDefault$1(vendor.isUnicodeSupported);
var _terminalLink = _interopRequireDefault$1(vendor.terminalLink);
// From the 'log-symbols' module
const unicodeLogSymbols = {
  __proto__: null,
  info: _yoctocolorsCjs.blue('ℹ'),
  success: _yoctocolorsCjs.green('✔'),
  warning: _yoctocolorsCjs.yellow('⚠'),
  error: _yoctocolorsCjs.red('✖')
};

// From the 'log-symbols' module
const fallbackLogSymbols = {
  __proto__: null,
  info: _yoctocolorsCjs.blue('i'),
  success: _yoctocolorsCjs.green('√'),
  warning: _yoctocolorsCjs.yellow('‼'),
  error: _yoctocolorsCjs.red('×')
};

// From the 'log-symbols' module
const logSymbols = colorOrMarkdown.logSymbols = (0, _isUnicodeSupported.default)() ? unicodeLogSymbols : fallbackLogSymbols;
const markdownLogSymbols = {
  __proto__: null,
  info: ':information_source:',
  error: ':stop_sign:',
  success: ':white_check_mark:',
  warning: ':warning:'
};
class ColorOrMarkdown {
  constructor(useMarkdown) {
    this.useMarkdown = !!useMarkdown;
  }
  header(text, level = 1) {
    return this.useMarkdown ? `\n${''.padStart(level, '#')} ${text}\n` : _yoctocolorsCjs.underline(`\n${level === 1 ? _yoctocolorsCjs.bold(text) : text}\n`);
  }
  bold(text) {
    return this.useMarkdown ? `**${text}**` : _yoctocolorsCjs.bold(`${text}`);
  }
  italic(text) {
    return this.useMarkdown ? `_${text}_` : _yoctocolorsCjs.italic(`${text}`);
  }
  hyperlink(text, url, {
    fallback = true,
    fallbackToUrl
  } = {}) {
    if (!url) return text;
    return this.useMarkdown ? `[${text}](${url})` : (0, _terminalLink.default)(text, url, {
      fallback: fallbackToUrl ? (_text, url) => url : fallback
    });
  }
  list(items) {
    const indentedContent = items.map(item => this.indent(item).trimStart());
    return this.useMarkdown ? `* ${indentedContent.join('\n* ')}\n` : `${indentedContent.join('\n')}\n`;
  }
  get logSymbols() {
    return this.useMarkdown ? markdownLogSymbols : logSymbols;
  }
  indent(text, level = 1) {
    const indent = ''.padStart(level * 2, ' ');
    return indent + text.split('\n').join('\n' + indent);
  }
  json(value) {
    return this.useMarkdown ? '```json\n' + JSON.stringify(value) + '\n```' : JSON.stringify(value);
  }
}
colorOrMarkdown.ColorOrMarkdown = ColorOrMarkdown;

var misc = {};

Object.defineProperty(misc, "__esModule", {
  value: true
});
misc.createDebugLogger = createDebugLogger;
misc.isErrnoException = isErrnoException;
misc.stringJoinWithSeparateFinalSeparator = stringJoinWithSeparateFinalSeparator;
var _colorOrMarkdown = colorOrMarkdown;
function createDebugLogger(printDebugLogs) {
  return printDebugLogs ? (...params) => console.error(_colorOrMarkdown.logSymbols.info, ...params) : () => {};
}
function isErrnoException(value) {
  if (!(value instanceof Error)) {
    return false;
  }
  return value.code !== undefined;
}
function stringJoinWithSeparateFinalSeparator(list, separator = ' and ') {
  const values = list.filter(value => !!value);
  if (values.length < 2) {
    return values[0] || '';
  }
  const finalValue = values.pop();
  return values.join(', ') + separator + finalValue;
}

var sdk = {};

var settings$1 = {};

Object.defineProperty(settings$1, "__esModule", {
  value: true
});
settings$1.getSetting = getSetting;
settings$1.updateSetting = updateSetting;
var _nodeFs = require$$0;
var _nodeOs = require$$1$1;
var _nodePath = require$$1$2;
var _yoctoSpinner = require$$3;
let dataHome = process.platform === 'win32' ? process.env['LOCALAPPDATA'] : process.env['XDG_DATA_HOME'];
if (!dataHome) {
  if (process.platform === 'win32') throw new Error('missing %LOCALAPPDATA%');
  const home = _nodeOs.homedir();
  dataHome = _nodePath.join(home, ...(process.platform === 'darwin' ? ['Library', 'Application Support'] : ['.local', 'share']));
}
const settingsPath = _nodePath.join(dataHome, 'socket', 'settings');
let settings = {};
if ((0, _nodeFs.existsSync)(settingsPath)) {
  const raw = (0, _nodeFs.readFileSync)(settingsPath, 'utf-8');
  try {
    settings = JSON.parse(Buffer.from(raw, 'base64').toString());
  } catch {
    _yoctoSpinner().warning(`Failed to parse settings at ${settingsPath}`);
  }
} else {
  (0, _nodeFs.mkdirSync)(_nodePath.dirname(settingsPath), {
    recursive: true
  });
}
function getSetting(key) {
  return settings[key];
}
let pendingSave = false;
function updateSetting(key, value) {
  settings[key] = value;
  if (!pendingSave) {
    pendingSave = true;
    process.nextTick(() => {
      pendingSave = false;
      (0, _nodeFs.writeFileSync)(settingsPath, Buffer.from(JSON.stringify(settings)).toString('base64'));
    });
  }
}

var _interopRequireDefault = vendor.interopRequireDefault.default;
Object.defineProperty(sdk, "__esModule", {
  value: true
});
sdk.FREE_API_KEY = void 0;
sdk.getDefaultKey = getDefaultKey;
sdk.setupSdk = setupSdk;
var _prompts = require$$1$3;
var _hpagent = require$$2;
var _isInteractive = _interopRequireDefault(vendor.isInteractive);
var _sdk = require$$4;
var _constants = constants.constants;
var _errors = errors;
var _settings = settings$1;
sdk.FREE_API_KEY = 'sktsec_t_--RAN5U4ivauy4w37-6aoKyYPDt5ZbaT5JBVMqiwKo_api';

// This API key should be stored globally for the duration of the CLI execution
let defaultKey;
function getDefaultKey() {
  defaultKey = process.env['SOCKET_SECURITY_API_KEY'] || (0, _settings.getSetting)('apiKey') || defaultKey;
  return defaultKey;
}

// The API server that should be used for operations
let defaultAPIBaseUrl;
function getDefaultAPIBaseUrl() {
  defaultAPIBaseUrl = process.env['SOCKET_SECURITY_API_BASE_URL'] || (0, _settings.getSetting)('apiBaseUrl') || undefined;
  return defaultAPIBaseUrl;
}

// The API server that should be used for operations
let defaultApiProxy;
function getDefaultHTTPProxy() {
  defaultApiProxy = process.env['SOCKET_SECURITY_API_PROXY'] || (0, _settings.getSetting)('apiProxy') || undefined;
  return defaultApiProxy;
}
async function setupSdk(apiKey = getDefaultKey(), apiBaseUrl = getDefaultAPIBaseUrl(), proxy = getDefaultHTTPProxy()) {
  if (typeof apiKey !== 'string' && (0, _isInteractive.default)()) {
    apiKey = await (0, _prompts.password)({
      message: 'Enter your Socket.dev API key (not saved, use socket login to persist)'
    });
    defaultKey = apiKey;
  }
  if (!apiKey) {
    throw new _errors.AuthError('You need to provide an API key');
  }
  let agent;
  if (proxy) {
    agent = {
      http: new _hpagent.HttpProxyAgent({
        proxy
      }),
      https: new _hpagent.HttpsProxyAgent({
        proxy
      })
    };
  }
  const sdkOptions = {
    agent,
    baseUrl: apiBaseUrl,
    userAgent: (0, _sdk.createUserAgentFromPkgJson)(require(_constants.rootPkgJsonPath))
  };
  return new _sdk.SocketSdk(apiKey || '', sdkOptions);
}

exports.colorOrMarkdown = colorOrMarkdown;
exports.errors = errors;
exports.misc = misc;
exports.sdk = sdk;
exports.settings = settings$1;
